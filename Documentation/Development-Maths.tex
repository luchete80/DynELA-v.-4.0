% !TeX spellcheck = en_US
% !TeX root = DynELA.tex
%
% LaTeX source file of DynELA FEM Code
%
% (c) by Olivier Pantal√© 2020
%
\chapter{DynELA Maths library}

\startcontents[chapters]
\printmyminitoc[2]\LETTRINE{T}he \DynELA~mathematical library is a set of classes and methods used to make all low level mathematics operations for the \DynELA. This library contains various classes from Vec3D which is a simple 3 components vector object used to store and manipulate data for coordinates and 3D vectors, to second, third and fourth order tensors, vectors, matrices and discrete functions.

\section{The Vec3D class}

%@DOC:Vec3D::Vec3D
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::Vec3D}}\label{Vec3D::Vec3D}\index[DL]{Vec3D!Vec3D}\\
Vec3D class.

This class is used to store information for coordinate vectors.
This file is the declaration file for the 3D vector class.
A 3D vector class is a vector with the following form:
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
  x_{1}\\
  x_{2}\\
  x_{3}
  \end{array}\right]
\end{equation*}
where $x_{i}$ are the components of the vector $\overrightarrow{x}$.
%@END

%@DOC:Vec3D::Vec3D()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::Vec3D(~)}}\label{Vec3D::Vec3D()}\index[DL]{Vec3D!Vec3D(~)}\\
Default constructor of the Vec3D class with initialization.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

By default this constructor initializes all components of the vector to zero.
%@END

%@DOC:Vec3D::Vec3D(double x, double y, double z)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::Vec3D(double x, double y, double z)}}\label{Vec3D::Vec3D(double x, double y, double z)}\index[DL]{Vec3D!Vec3D(double x, double y, double z)}\\
Constructor of the Vec3D class with initialization.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & x & first component of the Vec3D to create.\\
double & y & second component of the Vec3D to create.\\
double & z & third component of the Vec3D to create.
\end{tcolorbox}

%@END

\subsection{Basic operations}

%@DOC:Vec3D::operator=(double v)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator=(double v)}}\label{Vec3D::operator=(double v)}\index[DL]{Vec3D!operator=(double v)}\\
Fill a vector with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & v & Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the vector class.
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
v \\
v \\
v
\end{array}\right]
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $v$ is the scalar value defined by parameter v.
%@END

%@DOC:Vec3D::setValue(double x, double y, double z)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::setValue(double x, double y, double z)}}\label{Vec3D::setValue(double x, double y, double z)}\index[DL]{Vec3D!setValue(double x, double y, double z)}\\
Fill a vector with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The new Vec3D object created by the constructor.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & x & Component $x_{1}$ of the vector to create.\\
double & y & Component $x_{2}$ of the vector to create.\\
double & z & Component $x_{3}$ of the vector to create.
\end{tcolorbox}

Fill a vector with a scalar value for the $3$ components of the vector.
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
  x_{1} = x\\
  x_{2} = y\\
  x_{3} = z
  \end{array}\right]
\end{equation*}
%@END

%@DOC:Vec3D::operator*(double val)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator$\star$(double val)}}\label{Vec3D::operator*(double val)}\index[DL]{Vec3D!operator$\star$(double val)}\\
Multiplication of a vector by a scalar value.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&val&Scalar value to use for the multiplication operation.
\end{tcolorbox}

This method defines the multiplication of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \lambda \overrightarrow{x}
\end{equation*}
%@END

%@DOC:Vec3D::operator*(double val, Vec3D x)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator$\star$(double val, Vec3D x)}}\label{Vec3D::operator*(double val, Vec3D x)}\index[DL]{Vec3D!operator$\star$(double val, Vec3D x)}\\
Multiplication of a vector by a scalar value.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & val & Scalar value to use for the multiplication operation.\\
Vec3D & x & Vec3D to use for the multiplication operation.
\end{tcolorbox}

This method defines the multiplication of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \lambda \overrightarrow{x}
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\lambda$ is scalar value defined by parameter val.
%@END

%@DOC:Vec3D::operator*=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator$\star$=(double l)}}\label{Vec3D::operator*=(double l)}\index[DL]{Vec3D!operator$\star$=(double l)}\\
Multiplication of a vector by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{x} *= \lambda
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\lambda$ is the vector value defined by parameter l.
%@END

%@DOC:Vec3D::operator/(double val)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator/(double val)}}\label{Vec3D::operator/(double val)}\index[DL]{Vec3D!operator/(double val)}\\
Division of a vector by a scalar value.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&val&Scalar value to use for the division operation.
\end{tcolorbox}

This method defines the division of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \frac{1}{\lambda}\overrightarrow{x}
\end{equation*}
%@END

%@DOC:Vec3D::operator/=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator/=(double l)}}\label{Vec3D::operator/=(double l)}\index[DL]{Vec3D!operator/=(double l)}\\
Division of a vector by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{x} /= \lambda
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\lambda$ is the vector value defined by parameter l.
%@END

%@DOC:Vec3D::operator-(Vec3D x)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator-(Vec3D x)}}\label{Vec3D::operator-(Vec3D x)}\index[DL]{Vec3D!operator-(Vec3D x)}\\
Opposite of a vector.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the opposite operation.

This method defines the opposite of a vector.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = -\overrightarrow{x}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself.
%@END

%@DOC:Vec3D::operator-(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator-(Vec3D y)}}\label{Vec3D::operator-(Vec3D y)}\index[DL]{Vec3D!operator-(Vec3D y)}\\
Difference of 2 vectors.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & y & Vector to add to the current one.
\end{tcolorbox}

This method defines the difference of 2 vectors.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{z} = \overrightarrow{x} - \overrightarrow{y}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\overrightarrow{y}$ is the vector value defined by parameter y.
%@END

%@DOC:Vec3D::operator-=(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator-=(Vec3D y)}}\label{Vec3D::operator-=(Vec3D y)}\index[DL]{Vec3D!operator-=(Vec3D y)}\\
Difference of 2 vectors.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & y & Vector to add to the current one.
\end{tcolorbox}

This method defines the difference of 2 vectors.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{x} -= \overrightarrow{y}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\overrightarrow{y}$ is the vector value defined by parameter y.
%@END

%@DOC:Vec3D::operator+(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator+(Vec3D y)}}\label{Vec3D::operator+(Vec3D y)}\index[DL]{Vec3D!operator+(Vec3D y)}\\
Addition of 2 vectors.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & y & Vector to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 vectors.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{z} = \overrightarrow{x} + \overrightarrow{y}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\overrightarrow{y}$ is the vector value defined by parameter y.
%@END

%@DOC:Vec3D::operator+=(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::operator+=(Vec3D y)}}\label{Vec3D::operator+=(Vec3D y)}\index[DL]{Vec3D!operator+=(Vec3D y)}\\
Addition of 2 vectors.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & y & Vector to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 vectors.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{x} += \overrightarrow{y}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\overrightarrow{y}$ is the vector value defined by parameter y.
%@END

\subsection{Specific operations on Vec3D}

%@DOC:Vec3D::minVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::minVal(~)}}\label{Vec3D::minVal()}\index[DL]{Vec3D!minVal(~)}\\
Minumum value in a Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum value in a Vec3D.
%@END

%@DOC:Vec3D::minAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::minAbs(~)}}\label{Vec3D::minAbs()}\index[DL]{Vec3D!minAbs(~)}\\
Minumum absolute value in a Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum absolute value in a Vec3D.
%@END

%@DOC:Vec3D::maxVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::maxVal(~)}}\label{Vec3D::maxVal()}\index[DL]{Vec3D!maxVal(~)}\\
Maximum value in a Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum value in a Vec3D.
%@END

%@DOC:Vec3D::maxAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::maxAbs(~)}}\label{Vec3D::maxAbs()}\index[DL]{Vec3D!maxAbs(~)}\\
Maximum absolute value in a Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum absolute value in a Vec3D.
%@END

%@DOC:Vec3D::dot()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::dot(~)}}\label{Vec3D::dot()}\index[DL]{Vec3D!dot(~)}\\
Returns the dot product of a Vec3D by itself.\\ \hspace*{10mm}$\hookrightarrow$ double : The dot product.

This method returns dot product of a Vec3D by itself defined by:
\begin{equation*}
\left\Vert \overrightarrow{x} \right\Vert^2  = x_{1}^2 + x_{2}^2 + x_{3}^2
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself.
%@END

%@DOC:Vec3D::dot(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::dot(Vec3D y)}}\label{Vec3D::dot(Vec3D y)}\index[DL]{Vec3D!dot(Vec3D y)}\\
Dot product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double : The dot product.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & y & Vec3D $\overrightarrow{y}$ to use for the dot product operation.
\end{tcolorbox}

This method returns the dot product of two Vec3D defined by the following equation:
\begin{equation*}
m = \overrightarrow{x}\cdot\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\overrightarrow{y}$ is given by the parameter y.
%@END

%@DOC:Vec3D::dyadic()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::dyadic(~)}}\label{Vec3D::dyadic()}\index[DL]{Vec3D!dyadic(~)}\\
Dyadic product of a Vec3D by itsefl.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

This method returns the dyadic product of two Vec3D defined by the following equation:
\begin{equation*}
\T = \overrightarrow{x}\otimes\overrightarrow{x},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself. The result of this operation is a symmetric second order tensor.
%@END

%@DOC:Vec3D::dyadic(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::dyadic(Vec3D y)}}\label{Vec3D::dyadic(Vec3D y)}\index[DL]{Vec3D!dyadic(Vec3D y)}\\
Dyadic product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D&y&Vec3D $\overrightarrow{y}$ to use for the dyadic product operation.
\end{tcolorbox}

This method returns the dyadic product of two Vec3D defined by the following equation:
\begin{equation*}
\T = \overrightarrow{x}\otimes\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vec3D::normalize()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::normalize(~)}}\label{Vec3D::normalize()}\index[DL]{Vec3D!normalize(~)}\\
Normalize the Vec3D.

This method modifies the given vector and makes its norm equal to $1$.
%@END

%@DOC:Vec3D::getNormalized()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::getNormalized(~)}}\label{Vec3D::getNormalized()}\index[DL]{Vec3D!getNormalized(~)}\\
Get the normalized Vec3D.

This method returns a colinear Vec3D with a norm equal to $1$.
%@END

%@DOC:Vec3D::vectorProduct(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::vectorProduct(Vec3D y)}}\label{Vec3D::vectorProduct(Vec3D y)}\index[DL]{Vec3D!vectorProduct(Vec3D y)}\\
Vector product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & y & Vec3D $\overrightarrow{y}$ to use for the vector product operation.
\end{tcolorbox}

This method returns the vector product of two Vec3D defined by the following equation:
\begin{equation*}
\overrightarrow{w} = \overrightarrow{x}\land\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\overrightarrow{y}$ is given by the parameter y.
%@END

%@DOC:Vec3D::J2()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::J2(~)}}\label{Vec3D::J2()}\index[DL]{Vec3D!J2(~)}\\
J2 norm of a vector.\\ \hspace*{10mm}$\hookrightarrow$ double : The J2 of the vector.

This method returns the J2 norm $s$ of a vector $\overrightarrow{x}$ defined by:
\begin{equation*}
s = \left\Vert \overrightarrow{x} \right\Vert  = \sqrt {x_{1}^2 + x_{2}^2 + x_{3}^2}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself.
%@END

%@DOC:Vec3D::squareNorm()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::squareNorm(~)}}\label{Vec3D::squareNorm()}\index[DL]{Vec3D!squareNorm(~)}\\
Square norm of a vector.\\ \hspace*{10mm}$\hookrightarrow$ double : The square of the vector.

This method returns the square norm $s$ of a vector $\overrightarrow{x}$ defined by:
\begin{equation*}
s = \left\Vert \overrightarrow{x} \right\Vert^2  = {x_{1}^2 + x_{2}^2 + x_{3}^2}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself.
%@END

%@DOC:Vec3D::distance(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::distance(Vec3D y)}}\label{Vec3D::distance(Vec3D y)}\index[DL]{Vec3D!distance(Vec3D y)}\\
Distance between two points.\\ \hspace*{10mm}$\hookrightarrow$ double : The distance.

This method computes the distance between two points using an Euclidian norm.
\begin{equation*}
d = \left\Vert \overrightarrow{y} - \overrightarrow{x} \right\Vert
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\overrightarrow{y}$ is the second vector of the operation.
%@END

%@DOC:Vec3D::squareDistance(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::squareDistance(Vec3D y)}}\label{Vec3D::squareDistance(Vec3D y)}\index[DL]{Vec3D!squareDistance(Vec3D y)}\\
Square of distance between two points.\\ \hspace*{10mm}$\hookrightarrow$ double : The distance.

This method computes the square of the distance between two points using an Euclidian norm.
\begin{equation*}
d = {\left\Vert \overrightarrow{y} - \overrightarrow{x} \right\Vert}^2
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\overrightarrow{y}$ is the second vector of the operation.
%@END

%@DOC:Vec3D::ewProduct(Vec3D y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::ewProduct(Vec3D y)}}\label{Vec3D::ewProduct(Vec3D y)}\index[DL]{Vec3D!ewProduct(Vec3D y)}\\
Element-wise product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & y & Vec3D $\overrightarrow{y}$ to use for the element-wise product operation.
\end{tcolorbox}

This method returns the vector product of two Vec3D defined by the following equation:
\begin{equation*}
w_i = x_i y_i,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\overrightarrow{y}$ is given by the parameter y.
%@END

%@DOC:Vec3D::ewProduct(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vec3D::ewProduct(Tensor2 B)}}\label{Vec3D::ewProduct(Tensor2 B)}\index[DL]{Vec3D!ewProduct(Tensor2 B)}\\
Element-wise product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Tensor2 $\B$ to use for the element-wise product operation.
\end{tcolorbox}

This method returns the vector product of a Vec3D and a Tensor2 defined by the following equation:
\begin{equation*}
A_{ij} = x_i T_{ij},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\B$ is given by the parameter B.
%@END

\section{The Tensor2 class}

%@DOC:Tensor2::Tensor2
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::Tensor2}}\label{Tensor2::Tensor2}\index[DL]{Tensor2!Tensor2}\\
Second order tensor class.

The Tensor2 library is used to store second order tensors defined in the \DynELA.
The Tensor2 class is used to store and manage data relative to a second order tensor which can be seen as a $3\times3$ matrix with the following form:
\begin{equation*}
\T=\left[\begin{array}{ccc}
  T_{11} & T_{12} & T_{13}\\
  T_{21} & T_{22} & T_{23}\\
  T_{31} & T_{32} & T_{33}
  \end{array}\right]
\end{equation*}
where $T_{ij}$ are the components of the second order tensor $\T$.
Concerning the internal storage of data, the Tensor2 data is stored in a vector of $9$ components named \textsf{\_data} using the following storage scheme:
\begin{equation*}
\T=\left[\begin{array}{ccc}
    T_{0} & T_{1} & T_{2}\\
    T_{3} & T_{4} & T_{5}\\
    T_{6} & T_{7} & T_{8}
    \end{array}\right]
\end{equation*}
%@END

%@DOC:Tensor2::Tensor2()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::Tensor2(~)}}\label{Tensor2::Tensor2()}\index[DL]{Tensor2!Tensor2(~)}\\
Default constructor of the Tensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : The new Tensor2 object created by the constructor.

This is the default constructor of the Tensor2 class, where all components are initialized to zero by default.
\begin{equation*}
\T=\left[\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0
\end{array}\right]
\end{equation*}
%@END

%@DOC:Tensor2::Tensor2(double t11, double t12, ...)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::Tensor2(double t11, double t12, ...)}}\label{Tensor2::Tensor2(double t11, double t12, ...)}\index[DL]{Tensor2!Tensor2(double t11, double t12, ...)}\\
Constructor of the Tensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : The new Tensor2 object created by the constructor.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & t11 & Component $T_{11}$ of the second order tensor.\\
double & t12 & Component $T_{12}$ of the second order tensor.\\
double & t13 & Component $T_{13}$ of the second order tensor.\\
double & t21 & Component $T_{21}$ of the second order tensor.\\
double & t22 & Component $T_{22}$ of the second order tensor.\\
double & t23 & Component $T_{23}$ of the second order tensor.\\
double & t31 & Component $T_{31}$ of the second order tensor.\\
double & t32 & Component $T_{32}$ of the second order tensor.\\
double & t33 & Component $T_{33}$ of the second order tensor.
\end{tcolorbox}

Constructor of a second order tensor with explicit initialization of the $9$ components of the tensor.
\begin{equation*}
\T=\left[\begin{array}{ccc}
  T_{11} & T_{12} & T_{13}\\
  T_{21} & T_{22} & T_{23}\\
  T_{31} & T_{32} & T_{33}
  \end{array}\right]
\end{equation*}
%@END

%@DOC:Tensor2::operator=(SymTensor2 T)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator=(SymTensor2 T)}}\label{Tensor2::operator=(SymTensor2 T)}\index[DL]{Tensor2!operator=(SymTensor2 T)}\\
Copy the content of a SymTensor2 into a Tensor2.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & T & Symmetric second order tensor to copy.
\end{tcolorbox}

The result of this operation is a second order tensor as a copy of a symmetric second order tensor where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

\subsection{Basic operations}

%@DOC:Tensor2::setToZero()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::setToZero(~)}}\label{Tensor2::setToZero()}\index[DL]{Tensor2!setToZero(~)}\\
Zero second order tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

This method transforms the current second order tensor to a zero tensor.
\begin{equation*}
\T=\left[\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0
\end{array}\right]
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::setToUnity()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::setToUnity(~)}}\label{Tensor2::setToUnity()}\index[DL]{Tensor2!setToUnity(~)}\\
Unity second order tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

This method transforms the current tensor to a unity tensor.
\begin{equation*}
\T=\left[\begin{array}{ccc}
1&0&0\\
0&1&0\\
0&0&1
\end{array}\right]
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::transpose()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::transpose(~)}}\label{Tensor2::transpose()}\index[DL]{Tensor2!transpose(~)}\\
Transpose of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : The transpose of the second order tensor.

This method defines the transpose of a second order tensor.
The result of this operation is a second order tensor defined by the following equation:
\begin{equation*}
\B=\A^T =\left[\begin{array}{ccc}
  A_{11} & A_{21} & A_{31}\\
  A_{12} & A_{22} & A_{32}\\
  A_{13} & A_{23} & A_{33}
  \end{array}\right]
\end{equation*}
where $\A$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::operator=(double v)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator=(double v)}}\label{Tensor2::operator=(double v)}\index[DL]{Tensor2!operator=(double v)}\\
Fill a second order tensor with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & v & Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the second order tensor class.
\begin{equation*}
\T=\left[\begin{array}{ccc}
v & v & v\\
v & v & v\\
v & v & v
\end{array}\right]
\end{equation*}
where $\T$ is a second order tensor defined by the object itself and $v$ is the scalar value defined by parameter v.
%@END

%@DOC:Tensor2::operator+(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator+(Tensor2 B)}}\label{Tensor2::operator+(Tensor2 B)}\index[DL]{Tensor2!operator+(Tensor2 B)}\\
Addition of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Second order tensor to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A + \B
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\B$ is the second order tensor defined by parameter B.
%@END

%@DOC:Tensor2::operator-(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator-(Tensor2 B)}}\label{Tensor2::operator-(Tensor2 B)}\index[DL]{Tensor2!operator-(Tensor2 B)}\\
Difference of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Second order tensor to subtract to the current one.
\end{tcolorbox}

This method defines the subtraction of 2 second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A - \B
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\B$ is the second order tensor defined by parameter B.
%@END

%@DOC:Tensor2::operator-()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator-(~)}}\label{Tensor2::operator-()}\index[DL]{Tensor2!operator-(~)}\\
Opposite of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : The opposite second order tensor.

This method defines the opposite of a second order tensor.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = - \A
\end{equation*}
where $\A$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::operator*(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator$\star$(double l)}}\label{Tensor2::operator*(double l)}\index[DL]{Tensor2!operator$\star$(double l)}\\
Multiplication of a second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a second order tensor by a scalar value.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor2::operator/(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator/(double l)}}\label{Tensor2::operator/(double l)}\index[DL]{Tensor2!operator/(double l)}\\
Division of a second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a second order tensor by a scalar value.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:operator*(double l, Tensor2 A)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{operator$\star$(double l, Tensor2 A)}}\label{operator*(double l, Tensor2 A)}\\
Multiplication of a second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.\\
Tensor2 & A & Second order tensor to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a second order tensor by a scalar value.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a second order tensor and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor2::operator+=(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator+=(Tensor2 B)}}\label{Tensor2::operator+=(Tensor2 B)}\index[DL]{Tensor2!operator+=(Tensor2 B)}\\
Addition of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Second order tensor to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\A += \B
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\B$ is the second order tensor defined by parameter B.
%@END

%@DOC:Tensor2::operator-=(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator-=(Tensor2 B)}}\label{Tensor2::operator-=(Tensor2 B)}\index[DL]{Tensor2!operator-=(Tensor2 B)}\\
Difference of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Second order tensor to add to the current one.
\end{tcolorbox}

This method defines the difference of 2 second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\A -= \B
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\B$ is the second order tensor defined by parameter B.
%@END

%@DOC:Tensor2::operator*=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator$\star$=(double l)}}\label{Tensor2::operator*=(double l)}\index[DL]{Tensor2!operator$\star$=(double l)}\\
Multiplication of a second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a second order tensor by a scalar value.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\lambda \A
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor2::operator/=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator/=(double l)}}\label{Tensor2::operator/=(double l)}\index[DL]{Tensor2!operator/=(double l)}\\
Division of a second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a second order tensor by a scalar value.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor2::rowSum()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::rowSum(~)}}\label{Tensor2::rowSum()}\index[DL]{Tensor2!rowSum(~)}\\
Sum of the rows of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The sums of the rows of the second order tensor.

This method returns a vector by computing the sum of the components on all rows of a second order tensor.
The result of this operation is a vector $\overrightarrow{v}$ defined by:
\begin{equation*}
v_{i}=\sum_{j=1}^{3} T_{ji}
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::colSum()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::colSum(~)}}\label{Tensor2::colSum()}\index[DL]{Tensor2!colSum(~)}\\
Sum of the columns of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The sums of the columns of the second order tensor.

This method returns a vector by computing the sum of the components on all columns of a second order tensor.
The result of this operation is a vector $\overrightarrow{v}$ defined by:
\begin{equation*}
v_{i}=\sum_{j=1}^{3}T_{ij}
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::row(short r)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::row(short r)}}\label{Tensor2::row(short r)}\index[DL]{Tensor2!row(short r)}\\
Extraction of a row from a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The extracted row.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short & r & Row to extract
\end{tcolorbox}

This method returns a vector as part of a second order tensor.
The result of this operation with the argument r is a vector defined by:
\begin{equation*}
v_{i} = T_{ri}
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::col(short c)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::col(short c)}}\label{Tensor2::col(short c)}\index[DL]{Tensor2!col(short c)}\\
Extraction of a column from a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The extracted col.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short & c & Column to extract
\end{tcolorbox}

This method returns a vector as part of a second order tensor.
The result of this operation with the argument c is a vector defined by:
\begin{equation*}
v_{i} = T_{ic}
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::minVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::minVal(~)}}\label{Tensor2::minVal()}\index[DL]{Tensor2!minVal(~)}\\
Minimum component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The minimum component of the second order tensor.

This method returns the minimum component in a second order tensor.
%@END

%@DOC:Tensor2::minAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::minAbs(~)}}\label{Tensor2::minAbs()}\index[DL]{Tensor2!minAbs(~)}\\
Minimum absolute component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The minimum component of the second order tensor.

This method returns the minimum absolute component in a second order tensor.
%@END

%@DOC:Tensor2::maxVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::maxVal(~)}}\label{Tensor2::maxVal()}\index[DL]{Tensor2!maxVal(~)}\\
Maximum component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The maximum component of the second order tensor.

This method returns the maximum component in a second order tensor.
%@END

%@DOC:Tensor2::maxAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::maxAbs(~)}}\label{Tensor2::maxAbs()}\index[DL]{Tensor2!maxAbs(~)}\\
Maximum absolute component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The maximum component of the second order tensor.

This method returns the maximum absolute component in a second order tensor.
%@END

%@DOC:Tensor2::trace()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::trace(~)}}\label{Tensor2::trace()}\index[DL]{Tensor2!trace(~)}\\
Returns the trace of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The trace of the second order tensor.

This method returns the trace of a second order tensor, i.e. the sum $s$ of all the terms of the diagonal:
\begin{equation*}
s = \tr[\T] = T_{11}+T_{22}+T_{33}
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::thirdTrace()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::thirdTrace(~)}}\label{Tensor2::thirdTrace()}\index[DL]{Tensor2!thirdTrace(~)}\\
Returns the average value of the trace of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The third of the trace of the second order tensor.

This method returns average value of the trace of a second order tensor, i.e. the sum $s$ of all the terms of the diagonal divided by 3:
\begin{equation*}
s = \frac{1}{3} \tr[\T] =  \frac{1}{3} \left( T_{11}+T_{22}+T_{33} \right)
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::minor()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::minor(~)}}\label{Tensor2::minor()}\index[DL]{Tensor2!minor(~)}\\
Minor of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : The minor of the second order tensor.

This method returns the minor of a second order tensor.
\begin{equation*}
T^{minor} = \left[\begin{array}{ccc}
T_{22}T_{33}-T_{32}T_{23} & T_{33}T_{21}-T_{23}T_{31} & T_{21}T_{32}-T_{31}T_{22}\\
T_{12}T_{33}-T_{13}T_{32} & T_{33}T_{11}-T_{13}T_{31} & T_{11}T_{32}-T_{31}T_{12}\\
T_{12}T_{23}-T_{22}T_{13} & T_{23}T_{11}-T_{13}T_{21} & T_{11}T_{22}-T_{21}T_{12}
\end{array}
\right]
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::cofactors()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::cofactors(~)}}\label{Tensor2::cofactors()}\index[DL]{Tensor2!cofactors(~)}\\
Cofactors of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : The cofactor of the second order tensor.

This method returns the cofactor of a second order tensor.
\begin{equation*}
T^{cof} = \left[\begin{array}{ccc}
T_{22}T_{33}-T_{32}T_{23} & T_{23}T_{31}-T_{33}T_{21} & T_{21}T_{32}-T_{31}T_{22}\\
T_{13}T_{32}-T_{12}T_{33} & T_{33}T_{11}-T_{13}T_{31} & T_{31}T_{12}-T_{11}T_{32}\\
T_{12}T_{23}-T_{22}T_{13} & T_{13}T_{21}-T_{23}T_{11} & T_{11}T_{22}-T_{21}T_{12}
\end{array}
\right]
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::solve(Vec3D x)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::solve(Vec3D x)}}\label{Tensor2::solve(Vec3D x)}\index[DL]{Tensor2!solve(Vec3D x)}\\
Solves a small linear system $\A\cdot \overrightarrow{x} = \overrightarrow{b}$.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The solution of the linear system.

This method returns the solution of a small linear system with the following form:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\overrightarrow{x}$ is a vector defined by parameter x.
%@END

\subsection{Specific operations}

%@DOC:Tensor2::dot(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::dot(Tensor2 B)}}\label{Tensor2::dot(Tensor2 B)}\index[DL]{Tensor2!dot(Tensor2 B)}\\
Single contracted product of two second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\B$ is the second order tensor defined by parameter B.
%@END

%@DOC:Tensor2::dot()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::dot(~)}}\label{Tensor2::dot()}\index[DL]{Tensor2!dot(~)}\\
Single contracted product of a second order tensor by itself.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

This method defines a single contracted product of a second order tensor by itself.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \A
\end{equation*}
where $\A$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::dotTxN()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::dotTxN(~)}}\label{Tensor2::dotTxN()}\index[DL]{Tensor2!dotTxN(~)}\\
Single contracted product of a second order tensor by its transpose.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the multiplication operation.

This method defines a single contracted product of a second order tensor by its transpose.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A^T\cdot \A
\end{equation*}
where $\A$ is a second order tensor defined by the object itself. Result is a symmetric second order tensor.
%@END

%@DOC:Tensor2::dotNxT()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::dotNxT(~)}}\label{Tensor2::dotNxT()}\index[DL]{Tensor2!dotNxT(~)}\\
Single contracted product of a second order tensor by its transpose.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the multiplication operation.

This method defines a single contracted product of a second order tensor by its transpose.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \A^T
\end{equation*}
where $\A$ is a second order tensor defined by the object itself. Result is a symmetric second order tensor.
%@END

%@DOC:Tensor2::operator*(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator$\star$(Tensor2 B)}}\label{Tensor2::operator*(Tensor2 B)}\index[DL]{Tensor2!operator$\star$(Tensor2 B)}\\
Single contracted product of two second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\B$ is the second order tensor defined by parameter B.
%@END

%@DOC:Tensor2::operator*(SymTensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator$\star$(SymTensor2 B)}}\label{Tensor2::operator*(SymTensor2 B)}\index[DL]{Tensor2!operator$\star$(SymTensor2 B)}\\
Single contracted product of a second order tensor and a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of a second order tensor and a symmetric second order tensor.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\B$ is a symmetric second order tensor defined by parameter B.
%@END

%@DOC:Tensor2::doubleDot(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::doubleDot(Tensor2 B)}}\label{Tensor2::doubleDot(Tensor2 B)}\index[DL]{Tensor2!doubleDot(Tensor2 B)}\\
Double contracted product of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ double : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a double contracted product of two second order tensors.
The result of this operation is a scalar $s$ defined by:
\begin{equation*}
s = \A : \B = \sum_{i=1}^{3} \sum_{j=1}^{3} A_{ij}\times B_{ij}
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\B$ is a second order tensor defined by parameter B.
%@END

%@DOC:Tensor2::doubleDot()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::doubleDot(~)}}\label{Tensor2::doubleDot()}\index[DL]{Tensor2!doubleDot(~)}\\
Double contracted product of a second order tensor by itself.\\ \hspace*{10mm}$\hookrightarrow$ double : Result of the multiplication operation.

This method defines a double contracted product of a second order tensor by itself.
The result of this operation is a scalar $s$ defined by:
\begin{equation*}
s = \A : \A = \sum_{i=1}^{3} \sum_{j=1}^{3} A_{ij}\times A_{ij}
\end{equation*}
where $\A$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::operator*(Vec3D V)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::operator$\star$(Vec3D V)}}\label{Tensor2::operator*(Vec3D V)}\index[DL]{Tensor2!operator$\star$(Vec3D V)}\\
Multiplication of a second order tensor by a vector.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & V & Vec3D to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a second order tensor by a vector.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\overrightarrow{x}$ is a Vec3D defined by parameter V.
%@END

%@DOC:Tensor2::deviator()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::deviator(~)}}\label{Tensor2::deviator()}\index[DL]{Tensor2!deviator(~)}\\
Deviatoric part of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : The deviatoric part of the second order tensor.

This method defines the deviatoric part of a second order tensor.
The result of this operation is a second order tensor defined by the following equation:
\begin{equation*}
\A^d=\A-\frac{1}{3}\tr[\A].\Id
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\Id$ is the unit tensor.
%@END

%@DOC:Tensor2::symmetric()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::symmetric(~)}}\label{Tensor2::symmetric()}\index[DL]{Tensor2!symmetric(~)}\\
Symmetric part of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Symmetric part of the second order tensor.

This method returns the symmetric part of a second order tensor.
The result of this operation is a second order tensor defined by:
\begin{equation*}
\B = \left[\begin{array}{ccc}
 A_{11} & \frac{A_{12} + A_{21}}{2} & \frac{A_{13} + A_{31}}{2}\\
 \frac{A_{12} + A_{21}}{2} & A_{22} & \frac {A_{23} + A_{32}}{2}\\
 \frac{A_{13} + A_{31}}{2} & \frac {A_{23} + A_{32}}{2} & A_{33}\end{array}
\right]
\end{equation*}
where $\A$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::skewSymmetric()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::skewSymmetric(~)}}\label{Tensor2::skewSymmetric()}\index[DL]{Tensor2!skewSymmetric(~)}\\
Skew-symmetric part of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Symmetric part of the second order tensor.

This method returns the skew-symmetric part of a second order tensor.
The result of this operation is a second order tensor defined by:
\begin{equation*}
\B = \left[\begin{array}{ccc}
 A_{11} & \frac{A_{12} - A_{21}}{2} & \frac{A_{13} - A_{31}}{2}\\
 -\frac{A_{12} -  A_{21}}{2} & A_{22} & \frac {A_{23} - A_{32}}{2}\\
 -\frac{A_{13} - A_{31}}{2} & -\frac {A_{23} - A_{32}}{2} & A_{33}\end{array}
\right]
\end{equation*}
where $\A$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::det()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::det(~)}}\label{Tensor2::det()}\index[DL]{Tensor2!det(~)}\\
Determinant of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The determinant.

This method returns the determinant of a second order tensor.
The result of this operation is a scalar value defined by:
\begin{equation*}
d = T_{11} T_{22} T_{33} + T_{21} T_{32} T_{13} + T_{31} T_{12} T_{23} - T_{31} T_{22} T_{13} - T_{11} T_{32} T_{23} - T_{21} T_{12} T_{33}
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::inverse()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::inverse(~)}}\label{Tensor2::inverse()}\index[DL]{Tensor2!inverse(~)}\\
Inverse of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : The inverse of the second order tensor.

This method returns the inverse of a second order tensor.
The result of this operation is a second order tensor defined by:
\begin{equation*}
d = T_{11} T_{22} T_{33} + T_{21} T_{32} T_{13} + T_{31} T_{12} T_{23} - T_{31} T_{22} T_{13} - T_{11} T_{32} T_{23} - T_{21} T_{12} T_{33}
\end{equation*}
\begin{equation*}
T^{-1} = \frac {1}{d} \left[\begin{array}{ccc}
  T_{22}T_{33}-T_{23}T_{32}&T_{13}T_{32}-T_{12}T_{33}&T_{12}T_{23}-T_{13}T_{22}\\
  T_{23}T_{31}-T_{21}T_{33}&T_{11}T_{33}-T_{13}T_{31}&T_{13}T_{21}-T_{11}T_{23}\\
  T_{21}T_{32}-T_{22}T_{31}&T_{12}T_{31}-T_{11}T_{32}&T_{11}T_{22}-T_{12}T_{21}
  \end{array}
  \right]
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::norm()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::norm(~)}}\label{Tensor2::norm()}\index[DL]{Tensor2!norm(~)}\\
Norm of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The norm of the second order tensor.

This method returns the norm $s$ of a second order tensor $\T$ defined by:\begin{equation*}
s = \left\Vert \T \right\Vert  = \sqrt {T_{ij}:T_{ij}}
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::J2()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::J2(~)}}\label{Tensor2::J2()}\index[DL]{Tensor2!J2(~)}\\
J2 norm of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The J2 of the second order tensor.

This method returns the J2 norm $s$ of a second order tensor $\T$ defined by:
\begin{equation*}
s = \sqrt {\frac{3}{2}} \left\Vert \T \right\Vert  = \sqrt {\frac{3}{2} T_{ij}:T_{ij}}
\end{equation*}
where $\T$ is a second order tensor defined by the object itself.
%@END

\subsection{Advanced operations}

%@DOC:Tensor2::polarQL(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polarQL(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarQL(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarQL(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the QL with implicit shifts algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\U$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::polarQLLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polarQLLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarQLLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarQLLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the QL with implicit shifts algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\log[\U]$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::polarCuppen(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polarCuppen(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarCuppen(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarCuppen(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Cuppen‚Äôs Divide and Conquer algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\U$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarCuppenLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Cuppen‚Äôs Divide and Conquer algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\log[\U]$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::polarJacobi(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polarJacobi(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarJacobi(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarJacobi(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\U$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarJacobiLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\log[\U]$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::polarLapack(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polarLapack(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarLapack(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarLapack(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\U$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
It uses the \textsf{dgeev} function of the Lapack library which is far from efficient for a trivial 3x3 matrix. So this method is very slow.
%@END

%@DOC:Tensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarLapackLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\log[\U]$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
It uses the \textsf{dgeev} function of the Lapack library which is far from efficient for a trivial 3x3 matrix. So this method is very slow.
%@END

%@DOC:Tensor2::polar(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polar(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polar(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polar(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the old \DynELA algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\log[\U]$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:Tensor2::polarLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::polarLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the old \DynELA algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & U & Symmetric tensor $\U$\\
Tensor2 & R & Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

\begin{tcolorbox}[width=0.95\textwidth,myTab,tabularx={l||C|C|C},title=Performance of the polar algorithms]%,boxrule=0.5pt]
 & $\U$ version& $\log[\U]$ & Precision\\
 & CPU (ns) & CPU (ns) & $\F-\R\cdot\U$\\\hline\hline
polarLapack & $2163$ & $2360$ & $1.4210\times10^{-14}$ \\\hline
polar & $397$ & $432$ & $3.5527\times10^{-15}$\\\hline
polarQL & $246$ & $292$ & $1.0658\times10^{-14}$\\\hline
polarJacobi & $368$ & $390$ & $5.3291\times10^{-15}$\\\hline
polarCuppen & $234$ & $243$ & $3.5527\times10^{-15}$
\end{tcolorbox}

\section{The Symmetric Tensor2 class}

%@DOC:SymTensor2::SymTensor2
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::SymTensor2}}\label{SymTensor2::SymTensor2}\index[DL]{SymTensor2!SymTensor2}\\
Second order tensor class.

The SymTensor2 library is used to store symmetric second order tensors defined in the \DynELA.
The SymTensor2 class is used to store and manage data relative to a symmetric second order tensor which can be seen as a $3\times3$ matrix with the following form:
\begin{equation*}
\T=\left[\begin{array}{ccc}
  T_{11} & T_{12} & T_{13}\\
  T_{12} & T_{22} & T_{23}\\
  T_{13} & T_{23} & T_{33}
  \end{array}\right]
\end{equation*}
where $T_{ij}$ are the components of the symmetric second order tensor $\T$.
Concerning the internal storage of data, the SymTensor2 data is stored in vector of $6$ components named \textsf{\_data} using the following storage scheme:
\begin{equation*}
\T=\left[\begin{array}{ccc}
    T_{0} & T_{1} & T_{2}\\
    T_{1} & T_{3} & T_{4}\\
    T_{2} & T_{4} & T_{5}
    \end{array}\right]
\end{equation*}
%@END

%@DOC:SymTensor2::SymTensor2()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::SymTensor2(~)}}\label{SymTensor2::SymTensor2()}\index[DL]{SymTensor2!SymTensor2(~)}\\
Default constructor of the SymTensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : The new SymTensor2 object created by the constructor.

This is the default constructor of the SymTensor2 class, where all components are initialized to zero by default.
\begin{equation*}
\T=\left[\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0
\end{array}\right]
\end{equation*}
%@END

%@DOC:SymTensor2::SymTensor2(double t11, double t12, ...)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::SymTensor2(double t11, double t12, ...)}}\label{SymTensor2::SymTensor2(double t11, double t12, ...)}\index[DL]{SymTensor2!SymTensor2(double t11, double t12, ...)}\\
Constructor of the SymTensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : The new SymTensor2 object created by the constructor.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & t11 & Component $T_{11}$ of the symmetric second order tensor.\\
double & t12 & Component $T_{12}$ of the symmetric second order tensor.\\
double & t13 & Component $T_{13}$ of the symmetric second order tensor.\\
double & t22 & Component $T_{22}$ of the symmetric second order tensor.\\
double & t23 & Component $T_{23}$ of the symmetric second order tensor.\\
double & t33 & Component $T_{33}$ of the symmetric second order tensor.
\end{tcolorbox}

Constructor of a second order symmetric tensor with explicit initialization of the $6$ components of the tensor.
\begin{equation*}
\T=\left[\begin{array}{ccc}
  T_{11} & T_{12} & T_{13}\\
  T_{12} & T_{22} & T_{23}\\
  T_{13} & T_{23} & T_{33}
  \end{array}\right]
\end{equation*}
%@END

\subsection{Basic operations}

%@DOC:SymTensor2::setToZero()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::setToZero(~)}}\label{SymTensor2::setToZero()}\index[DL]{SymTensor2!setToZero(~)}\\
Zero symmetric second order tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

This method transforms the current symmetric second order tensor to a zero tensor.
\begin{equation*}
\T=\left[\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0
\end{array}\right]
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::setToUnity()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::setToUnity(~)}}\label{SymTensor2::setToUnity()}\index[DL]{SymTensor2!setToUnity(~)}\\
Unity symmetric second order tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

This method transforms the current symmetric second order tensor to a unity tensor.
\begin{equation*}
\T=\left[\begin{array}{ccc}
1&0&0\\
0&1&0\\
0&0&1
\end{array}\right]
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::operator=(double v)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator=(double v)}}\label{SymTensor2::operator=(double v)}\index[DL]{SymTensor2!operator=(double v)}\\
Fill a symmetric second order tensor with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & v & Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the symmetric second order tensor class.
\begin{equation*}
\T=\left[\begin{array}{ccc}
v & v & v\\
v & v & v\\
v & v & v
\end{array}\right]
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself and $v$ is the scalar value defined by parameter v.
%@END

%@DOC:SymTensor2::operator+=(SymTensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator+=(SymTensor2 B)}}\label{SymTensor2::operator+=(SymTensor2 B)}\index[DL]{SymTensor2!operator+=(SymTensor2 B)}\\
Addition of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & B & Second order tensor to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 second order tensors.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\A += \B
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\B$ is the second order tensor value defined by parameter B.
%@END

%@DOC:SymTensor2::operator-=(SymTensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator-=(SymTensor2 B)}}\label{SymTensor2::operator-=(SymTensor2 B)}\index[DL]{SymTensor2!operator-=(SymTensor2 B)}\\
Difference of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & B & Second order tensor to add to the current one.
\end{tcolorbox}

This method defines the difference of 2 second order tensors.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\A -= \B
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\B$ is the second order tensor value defined by parameter B.
%@END

%@DOC:SymTensor2::operator*=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator$\star$=(double l)}}\label{SymTensor2::operator*=(double l)}\index[DL]{SymTensor2!operator$\star$=(double l)}\\
Multiplication of a symmetric second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a symmetric second order tensor by a scalar value.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\lambda \A
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:SymTensor2::operator/=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator/=(double l)}}\label{SymTensor2::operator/=(double l)}\index[DL]{SymTensor2!operator/=(double l)}\\
Division of a symmetric second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a symmetric second order tensor by a scalar value.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:SymTensor2::operator+(SymTensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator+(SymTensor2 B)}}\label{SymTensor2::operator+(SymTensor2 B)}\index[DL]{SymTensor2!operator+(SymTensor2 B)}\\
Addition of 2 symmetric second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & B & Symmetric second order tensor to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 symmetric second order tensors.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \A + \B
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\B$ is the symmetric second order tensor value defined by parameter B.
%@END

%@DOC:SymTensor2::operator-(SymTensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator-(SymTensor2 B)}}\label{SymTensor2::operator-(SymTensor2 B)}\index[DL]{SymTensor2!operator-(SymTensor2 B)}\\
Subtraction of 2 symmetric second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & B & Symmetric second order tensor to subtract to the current one.
\end{tcolorbox}

This method defines the subtraction of 2 symmetric second order tensors.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \A - \B
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\B$ is the symmetric second order tensor value defined by parameter B.
%@END

%@DOC:SymTensor2::operator-()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator-(~)}}\label{SymTensor2::operator-()}\index[DL]{SymTensor2!operator-(~)}\\
Opposite of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : The opposite symmetric second order tensor.

This method defines the opposite of a symmetric second order tensor.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = - \A
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::operator*(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator$\star$(double l)}}\label{SymTensor2::operator*(double l)}\index[DL]{SymTensor2!operator$\star$(double l)}\\
Multiplication of a symmetric second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a symmetric second order tensor by a scalar value.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:SymTensor2::operator/(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator/(double l)}}\label{SymTensor2::operator/(double l)}\index[DL]{SymTensor2!operator/(double l)}\\
Division of a symmetric second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a symmetric second order tensor by a scalar value.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:operator*(double l, SymTensor2 A)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{operator$\star$(double l, SymTensor2 A)}}\label{operator*(double l, SymTensor2 A)}\\
Multiplication of a symmetric second order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.\\
SymTensor2 & A & Symmetric second order tensor to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a symmetric second order tensor by a scalar value.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a symmetric second order tensor and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:SymTensor2::rowSum()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::rowSum(~)}}\label{SymTensor2::rowSum()}\index[DL]{SymTensor2!rowSum(~)}\\
Sum of the rows of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The sums of the rows of the symmetric second order tensor.

This method returns a vector by computing the sum of the components on all rows of a symmetric second order tensor.
The result of this operation is a vector $\overrightarrow{v}$ defined by:
\begin{equation*}
v_{i}=\sum_{j=1}^{3} T_{ji}
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::colSum()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::colSum(~)}}\label{SymTensor2::colSum()}\index[DL]{SymTensor2!colSum(~)}\\
Sum of the columns of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The sums of the columns of the symmetric second order tensor.

This method returns a vector by computing the sum of the components on all columns of a symmetric second order tensor.
The result of this operation is a vector $\overrightarrow{v}$ defined by:
\begin{equation*}
v_{i}=\sum_{j=1}^{3}T_{ij}
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::row(short r)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::row(short r)}}\label{SymTensor2::row(short r)}\index[DL]{SymTensor2!row(short r)}\\
Extraction of a row from a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The extracted row.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short & r & Row to extract
\end{tcolorbox}

This method returns a vector as part of a symmetric second order tensor.
The result of this operation with the argument r is a vector defined by:
\begin{equation*}
v_{i} = T_{ri}
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::col(short c)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::col(short c)}}\label{SymTensor2::col(short c)}\index[DL]{SymTensor2!col(short c)}\\
Extraction of a column from a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The extracted col.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short & c & Column to extract
\end{tcolorbox}

This method returns a vector as part of a symmetric second order tensor.
The result of this operation with the argument c is a vector defined by:
\begin{equation*}
v_{i} = T_{ic}
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::minVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::minVal(~)}}\label{SymTensor2::minVal()}\index[DL]{SymTensor2!minVal(~)}\\
Minimum component in a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The minimum component of the symmetric second order tensor.

This method returns the minimum component in a symmetric second order tensor.
%@END

%@DOC:SymTensor2::minAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::minAbs(~)}}\label{SymTensor2::minAbs()}\index[DL]{SymTensor2!minAbs(~)}\\
Minimum absolute component in a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The minimum component of the symmetric second order tensor.

This method returns the minimum absolute component in a symmetric second order tensor.
%@END

%@DOC:SymTensor2::maxVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::maxVal(~)}}\label{SymTensor2::maxVal()}\index[DL]{SymTensor2!maxVal(~)}\\
Maximum component in a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The maximum component of the symmetric second order tensor.

This method returns the maximum component in a symmetric second order tensor.
%@END

%@DOC:SymTensor2::maxAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::maxAbs(~)}}\label{SymTensor2::maxAbs()}\index[DL]{SymTensor2!maxAbs(~)}\\
Maximum absolute component in a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The maximum component of the symmetric second order tensor.

This method returns the maximum absolute component in a symmetric second order tensor.
%@END

%@DOC:SymTensor2::trace()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::trace(~)}}\label{SymTensor2::trace()}\index[DL]{SymTensor2!trace(~)}\\
Returns the trace of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The trace of the second order tensor.

This method returns the trace of a symmetric second order tensor, i.e. the sum $s$ of all the terms of the diagonal:
\begin{equation*}
s = \tr[\T] = T_{11}+T_{22}+T_{33}
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::thirdTrace()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::thirdTrace(~)}}\label{SymTensor2::thirdTrace()}\index[DL]{SymTensor2!thirdTrace(~)}\\
Returns the average value of the trace of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The third of the trace of the second order tensor.

This method returns average value of the trace of a symmetric second order tensor, i.e. the sum $s$ of all the terms of the diagonal divided by 3:
\begin{equation*}
s = \frac{1}{3} \tr[\T] =  \frac{1}{3} \left( T_{11}+T_{22}+T_{33} \right)
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

\subsection{Specific operations}

%@DOC:SymTensor2::dot(SymTensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::dot(SymTensor2 B)}}\label{SymTensor2::dot(SymTensor2 B)}\index[DL]{SymTensor2!dot(SymTensor2 B)}\\
Single contracted product of two symmetric second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & B & Second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two symmetric second order tensors.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\B$ is the symmetric second order tensor defined by parameter B.
%@END

%@DOC:SymTensor2::dot()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::dot(~)}}\label{SymTensor2::dot()}\index[DL]{SymTensor2!dot(~)}\\
Single contracted product of a symmetric second order tensor by itself.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the multiplication operation.

This method defines a single contracted product of a symmetric second order tensor by itself.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \A \cdot \A
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::operator*(SymTensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator$\star$(SymTensor2 B)}}\label{SymTensor2::operator*(SymTensor2 B)}\index[DL]{SymTensor2!operator$\star$(SymTensor2 B)}\\
Single contracted product of two symmetric second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}  The result of this operation is a non symmetric second order tensor.}

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & B & Symmetric second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two symmetric second order tensors.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\B$ is the symmetric second order tensor defined by parameter B.
%@END

%@DOC:SymTensor2::operator*(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator$\star$(Tensor2 B)}}\label{SymTensor2::operator*(Tensor2 B)}\index[DL]{SymTensor2!operator$\star$(Tensor2 B)}\\
Single contracted product of two symmetric second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}  The result of this operation is a non symmetric second order tensor.}

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Symmetric second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two symmetric second order tensors.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\B$ is the symmetric second order tensor defined by parameter B.
%@END

%@DOC:SymTensor2::doubleDot(SymTensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::doubleDot(SymTensor2 B)}}\label{SymTensor2::doubleDot(SymTensor2 B)}\index[DL]{SymTensor2!doubleDot(SymTensor2 B)}\\
Double contracted product of 2 symmetric second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ double : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2 & B & Second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a double contracted product of two symmetric second order tensors.
The result of this operation is a scalar $s$ defined by:
\begin{equation*}
s = \A : \B = \sum_{i=1}^{3} \sum_{j=1}^{3} A_{ij}\times B_{ij}
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\B$ is a symmetric second order tensor defined by parameter B.
%@END

%@DOC:SymTensor2::doubleDot()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::doubleDot(~)}}\label{SymTensor2::doubleDot()}\index[DL]{SymTensor2!doubleDot(~)}\\
Double contracted product of a symmetric second order tensor by itself.\\ \hspace*{10mm}$\hookrightarrow$ double : Result of the multiplication operation.

This method defines a double contracted product of a symmetric second order tensor by itself.
The result of this operation is a scalar $s$ defined by:
\begin{equation*}
s = \A : \A = \sum_{i=1}^{3} \sum_{j=1}^{3} A_{ij}\times A_{ij}
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::operator*(Vec3D V)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::operator$\star$(Vec3D V)}}\label{SymTensor2::operator*(Vec3D V)}\index[DL]{SymTensor2!operator$\star$(Vec3D V)}\\
Multiplication of a symmetric second order tensor by a vector.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & V & Vec3D to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a symmetric second order tensor by a vector.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\overrightarrow{x}$ is a Vec3D defined by parameter V.
%@END

%@DOC:SymTensor2::deviator()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::deviator(~)}}\label{SymTensor2::deviator()}\index[DL]{SymTensor2!deviator(~)}\\
Deviatoric part of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : The deviatoric part of the symmetric second order tensor.

This method defines the deviatoric part of a symmetric second order tensor.
The result of this operation is a symmetric second order tensor defined by the following equation:
\begin{equation*}
\A^d=\A-\frac{1}{3}\tr[\A].\Id
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\Id$ is the unit tensor.
%@END

%@DOC:SymTensor2::det()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::det(~)}}\label{SymTensor2::det()}\index[DL]{SymTensor2!det(~)}\\
Determinant of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The determinant.

This method returns the determinant of a symmetric second second order tensor.
The result of this operation is a scalar value defined by:
\begin{equation*}
D = T_{11} T_{22} T_{33} + 2 T_{12} T_{23} T_{13} - T_{13} T_{22} T_{13} - T_{11} T_{23} T_{23} - T_{12} T_{12} T_{33}
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::inverse()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::inverse(~)}}\label{SymTensor2::inverse()}\index[DL]{SymTensor2!inverse(~)}\\
Inverse of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : The inverse of the symmetric second order tensor.

This method returns the inverse of a symmetric second order tensor.
The result of this operation is a symmetric second order tensor defined by:
\begin{equation*}
D = T_{11} T_{22} T_{33} + 2 T_{12} T_{23} T_{13} - T_{22} T_{13}^2 - T_{11} T_{23}^2 - T_{33} T_{12}^2
\end{equation*}
\begin{equation*}
T^{-1} = \frac {1}{D} \left[\begin{array}{ccc}
  T_{22}T_{33}-T_{23}^2&T_{13}T_{23}-T_{12}T_{33}&T_{12}T_{23}-T_{13}T_{22}\\
  T_{13}T_{23}-T_{12}T_{33}&T_{11}T_{33}-T_{13}^2&T_{12}T_{13}-T_{11}T_{23}\\
  T_{12}T_{23}-T_{13}T_{22}&T_{12}T_{13}-T_{11}T_{23}&T_{11}T_{22}-T_{12}^2
  \end{array}
  \right]
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::norm()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::norm(~)}}\label{SymTensor2::norm()}\index[DL]{SymTensor2!norm(~)}\\
Norm of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : The norm of the second order tensor.

This method returns the norm $s$ of a symmetric second order tensor $\T$ defined by:\begin{equation*}
s = \left\Vert \T \right\Vert  = \sqrt {T_{ij}:T_{ij}}
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::J2()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::J2(~)}}\label{SymTensor2::J2()}\index[DL]{SymTensor2!J2(~)}\\
J2 norm of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the J2 norm of a symmetric second order tensor defined by:
\begin{equation*}
\sqrt {\frac{3}{2}} \left\Vert s \right\Vert  = \sqrt {\frac{3}{2} s_{ij}:s_{ij}}
\end{equation*}
%@END

%@DOC:SymTensor2::vonMises()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::vonMises(~)}}\label{SymTensor2::vonMises()}\index[DL]{SymTensor2!vonMises(~)}\\
Returns the von Mises stress of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double : the von Mises equivalent stress.

This method returns the von Mises stress of a symmetric second order tensor defined by:
\begin{equation*}
\overline{\sigma} = \frac {1}{\sqrt{2}}\sqrt{(s_{11}-s_{22})^2+(s_{22}-s_{33})^2+(s_{33}-s_{11})^2+6(s_{12}^2+s_{23}^2+s_{31}^2)}
\end{equation*}
where $\Sig$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::minor()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::minor(~)}}\label{SymTensor2::minor()}\index[DL]{SymTensor2!minor(~)}\\
Minor of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : The minor of the symmetric second order tensor.

This method returns the minor of a symmetric second order tensor.
\begin{equation*}
T^{minor} = \left[\begin{array}{ccc}
T_{22}T_{33}-T_{23}T_{23} & T_{33}T_{12}-T_{23}T_{13} & T_{12}T_{23}-T_{13}T_{22}\\
T_{12}T_{33}-T_{13}T_{23} & T_{33}T_{11}-T_{13}T_{13} & T_{11}T_{23}-T_{13}T_{12}\\
T_{12}T_{23}-T_{22}T_{13} & T_{23}T_{11}-T_{13}T_{12} & T_{11}T_{22}-T_{12}T_{12}
\end{array}
\right]
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::cofactors()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::cofactors(~)}}\label{SymTensor2::cofactors()}\index[DL]{SymTensor2!cofactors(~)}\\
Cofactors of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : The cofactor of the symmetric second order tensor.

This method returns the cofactor of a symmetric second order tensor.
\begin{equation*}
T^{cof} = \left[\begin{array}{ccc}
T_{22}T_{33}-T_{23}T_{23} & T_{23}T_{13}-T_{33}T_{12} & T_{12}T_{23}-T_{13}T_{22}\\
T_{13}T_{23}-T_{12}T_{33} & T_{33}T_{11}-T_{13}T_{13} & T_{13}T_{12}-T_{11}T_{23}\\
T_{12}T_{23}-T_{22}T_{13} & T_{13}T_{12}-T_{23}T_{11} & T_{11}T_{22}-T_{12}T_{12}
\end{array}
\right]
\end{equation*}
where $\T$ is a symmetric second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::solve(Vec3D x)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::solve(Vec3D x)}}\label{SymTensor2::solve(Vec3D x)}\index[DL]{SymTensor2!solve(Vec3D x)}\\
Solves a small linear system A.x = b.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The solution of the linear system.

This method returns the solution of a small linear system with the following form:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\overrightarrow{x}$ is a vector defined by parameter x.
%@END

\subsection{Advanced operations}

%@DOC:SymTensor2::dotRxRT(Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::dotRxRT(Tensor2 R)}}\label{SymTensor2::dotRxRT(Tensor2 R)}\index[DL]{SymTensor2!dotRxRT(Tensor2 R)}\\
Special combination for a multiplication of 3 symmetric second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & R & Symmetric second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines the product of a symmetric tensor by two rotations defined by the following equation:
\begin{equation*}
\R = \Q \cdot \A \cdot \Q^T =\left[\begin{array}{ccc}
R_0 & R_1 & R_2\\
& R_3 & R_4\\
sym &  & R_5
\end{array}\right]
\end{equation*}
with:
\begin{align*}
R_0 & = A_0 Q_0^2 + 2 (A_1 Q_1 + A_2 Q_2)Q_0 + A_3 Q_1^2 + 2 A_4 Q_1 Q_2 + A_5 Q_2^2\\
R_1 & = (A_0 Q_3 + A_1 Q_4 + A_2 Q_5)Q_0 + (A_1 Q_3 + A_3 Q_4 + A_4 Q_5)Q_1 + (A_2 Q_3 + A_4 Q_4 + A_5 Q_5)Q_2\\
R_2 & = (A_0 Q_6 + A_1 Q_7 + A_2 Q_8)Q_0 + (A_1 Q_6 + A_3 Q_7 + A_4 Q_8)Q_1 + (A_2 Q_6 + A_4 Q_7 + A_5 Q_8)Q_2\\
R_3 & = A_0 Q_3^2 + 2 (A_1 Q_4 + A_2 Q_5)Q_3+ A_3 Q_4^2 + 2 A_4 Q_4 Q_5 + A_5 Q_5^2\\
R_4 & = (A_0 Q_6 + A_1 Q_7 + A_2 Q_8)Q_3 + (A_1 Q_6 + A_3 Q_7 + A_4 Q_8)Q_4 + (A_2 Q_6 + A_4 Q_7 + A_5 Q_8)Q_5\\
R_5 & = A_0 Q_6^2 + 2 (A_1 Q_7 + A_2 Q_8)Q_6+ A_3 Q_7^2 + 2 A_4 Q_7 Q_8 + A_5 Q_8^2
\end{align*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\Q$ an orthogonal tensor.
%@END

%@DOC:SymTensor2::dotRTxR(Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::dotRTxR(Tensor2 R)}}\label{SymTensor2::dotRTxR(Tensor2 R)}\index[DL]{SymTensor2!dotRTxR(Tensor2 R)}\\
Special combination for a multiplication of 3 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&R&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines the product of a symmetric tensor by two rotations defined by the following equation:
\begin{equation*}
\R = \Q^T \cdot \A \cdot \Q =\left[\begin{array}{ccc}
R_0 & R_1 & R_2\\
& R_3 & R_4\\
sym &  & R_5
\end{array}\right]
\end{equation*}
with:
\begin{align*}
R_0 &= A_0 Q_0^2 + 2 (A_1 Q_3 + A_2 Q_6) Q_0 + A_3 Q_3^2 + 2 A_4 Q_3 Q_6 + A_5 Q_6^2 \\
R_1 &= A_1 Q_1 Q_3 +A_2 Q_1 Q_6 + (A_0 Q_1 + A_1 Q_4 + A_2 Q_7) Q_0+ A_3 Q_3 Q_4 + A_4 Q_4 Q_6 + A_4 Q_3 Q_7 + A_5 Q_6 Q_7\\
R_2 &= A_1 Q_2 Q_3 + A_2 Q_2 Q_6 + Q_0 (A_0 Q_2 + A_1 Q_5 + A_2 Q_8) + A_3 Q_3 Q_5 + A_4 Q_5 Q_6 + A_4 Q_3 Q_8 + A_5 Q_6 Q_8\\
R_3 &= A_0 Q_1^2 + 2 (A_1 Q_4 + A_2 Q_7)Q_1 + A_3 Q_4^2 + 2 A_4 Q_4 Q_7 + A_5 Q_7^2\\
R_4 &= A_1 Q_2 Q_4 + A_2 Q_2 Q_7 + (A_0 Q_2 + A_1 Q_5 + A_2 Q_8)Q_1 + A_3 Q_4 Q_5 + A_4 Q_5 Q_7 + A_4 Q_4 Q_8 + A_5 Q_7 Q_8\\
R_5 &= A_0 Q_2^2 + 2 (A_1 Q_5 + A_2 Q_8) Q_2 + A_3 Q_5^2 + 2 A_4 Q_5 Q_8 + A_5 Q_8^2
\end{align*}
where $\A$ is a symmetric second order tensor defined by the object itself and $\Q$ an orthogonal tensor.
%@END

%@DOC:SymTensor2::polarQL(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polarQL(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarQL(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarQL(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the QL with implicit shifts algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\U$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::polarQLLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polarQLLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarQLLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarQLLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the QL with implicit shifts algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::polarCuppen(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polarCuppen(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarCuppen(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarCuppen(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Cuppen‚Äôs Divide and Conquer algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarCuppenLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Cuppen‚Äôs Divide and Conquer algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::polarJacobi(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polarJacobi(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarJacobi(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarJacobi(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarJacobiLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::polarLapack(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polarLapack(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarLapack(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarLapack(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
It uses the LAPACKE\_dgeev function of the Lapack library which is far from efficient for a trivial 3x3 matrix. So this method is very slow.
%@END

%@DOC:SymTensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarLapackLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
It uses the LAPACKE\_dgeev function of the Lapack library which is far from efficient for a trivial 3x3 matrix. So this method is very slow.
%@END

%@DOC:SymTensor2::polar(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polar(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polar(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polar(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the old \DynELA algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

%@DOC:SymTensor2::polarLnU(SymTensor2 U, Tensor2 R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{SymTensor2::polarLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the old \DynELA algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
where $\F$ is a second order tensor defined by the object itself.
%@END

\begin{tcolorbox}[width=0.95\textwidth,myTab,tabularx={l||C|C|C},title=Performance of the polar algorithms for symmetric tensors]%,boxrule=0.5pt]
 & $\U$ version& $\log[\U]$ & Precision\\
 & CPU (ns) & CPU (ns) & $\F-\R\cdot\U$\\\hline\hline
polarLapack & $2441$ & $2151$& $1.4210\times10^{-14}$ \\\hline
polar & $435$ & $436$& $3.5527\times10^{-15}$\\\hline
polarQL & $260$ & $281$& $1.0658\times10^{-14}$\\\hline
polarJacobi & $350$ & $356$ & $5.3291\times10^{-15}$\\\hline
polarCuppen & $206$ & $233$& $3.5527\times10^{-15}$
\end{tcolorbox}

\section{The Tensor3 class}

%@DOC:Tensor3::Tensor3
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::Tensor3}}\label{Tensor3::Tensor3}\index[DL]{Tensor3!Tensor3}\\
Third order tensor class.

The Tensor3 library is used to store third order tensors defined in the \DynELA.
The Tensor3 class is used to store and manage data relative to a third order tensor which can be seen as a $3\times3\times3$ matrix hard to represent on a plane,
where $T_{ijk}$ are the components of the third order tensor $\T$.
Concerning the internal storage of data, the Tensor3 data is stored in a vector of $27$ components named \textsf{\_data}.
%@END



%@DOC:Tensor3::Tensor3()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::Tensor3(~)}}\label{Tensor3::Tensor3()}\index[DL]{Tensor3!Tensor3(~)}\\
Default constructor of the Tensor3 class.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : The new Tensor3 object created by the constructor.

This is the default constructor of the Tensor3 class, where all components are initialized to zero by default.
%@END

\subsection{Basic operations}

%@DOC:Tensor3::setToUnity()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::setToUnity(~)}}\label{Tensor3::setToUnity()}\index[DL]{Tensor3!setToUnity(~)}\\
Unity third order tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

This method transforms the current tensor to a unity tensor.
\begin{equation*}
\T=\left[\begin{array}{ccc}
1&0&0\\
0&1&0\\
0&0&1
\end{array}\right]
\end{equation*}
where $\T$ is a third order tensor defined by the object itself.
%@END

%@DOC:Tensor3::operator+=(Tensor3 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator+=(Tensor3 B)}}\label{Tensor3::operator+=(Tensor3 B)}\index[DL]{Tensor3!operator+=(Tensor3 B)}\\
Addition of 2 third order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor3 & B & Third order tensor to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 third order tensors.
The result of this operation is also a third order tensor defined by:
\begin{equation*}
\A += \B
\end{equation*}
where $\A$ is a third order tensor defined by the object itself and $\B$ is the third order tensor value defined by parameter B.
%@END

%@DOC:Tensor3::operator-=(Tensor3 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator-=(Tensor3 B)}}\label{Tensor3::operator-=(Tensor3 B)}\index[DL]{Tensor3!operator-=(Tensor3 B)}\\
Difference of 2 third order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor3 & B & Third order tensor to add to the current one.
\end{tcolorbox}

This method defines the difference of 2 third order tensors.
The result of this operation is also a third order tensor defined by:
\begin{equation*}
\A -= \B
\end{equation*}
where $\A$ is a third order tensor defined by the object itself and $\B$ is the third order tensor value defined by parameter B.
%@END

%@DOC:Tensor3::operator*=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator$\star$=(double l)}}\label{Tensor3::operator*=(double l)}\index[DL]{Tensor3!operator$\star$=(double l)}\\
Multiplication of a third order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a third order tensor by a scalar value.
The result of this operation is also a third order tensor defined by:
\begin{equation*}
\lambda \A
\end{equation*}
where $\A$ is a third order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor3::operator/=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator/=(double l)}}\label{Tensor3::operator/=(double l)}\index[DL]{Tensor3!operator/=(double l)}\\
Division of a third order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a third order tensor by a scalar value.
The result of this operation is also a third order tensor defined by:
\begin{equation*}
\frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a third order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor3::operator=(double v)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator=(double v)}}\label{Tensor3::operator=(double v)}\index[DL]{Tensor3!operator=(double v)}\\
Fill a third order tensor with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & v & Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the third order tensor class.
%@END

%@DOC:Tensor3::operator+(Tensor3 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator+(Tensor3 B)}}\label{Tensor3::operator+(Tensor3 B)}\index[DL]{Tensor3!operator+(Tensor3 B)}\\
Addition of 2 third order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor3 & B & Third order tensor to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 third order tensors.
The result of this operation is also a third order tensor defined by:
\begin{equation*}
\T = \A + \B
\end{equation*}
where $\A$ is a third order tensor defined by the object itself and $\B$ is the third order tensor value defined by parameter B.
%@END

%@DOC:Tensor3::operator-(Tensor3 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator-(Tensor3 B)}}\label{Tensor3::operator-(Tensor3 B)}\index[DL]{Tensor3!operator-(Tensor3 B)}\\
Subtraction of 2 third order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor3 & B & Third order tensor to subtract to the current one.
\end{tcolorbox}

This method defines the subtraction of 2 third order tensors.
The result of this operation is also a third order tensor defined by:
\begin{equation*}
\T = \A - \B
\end{equation*}
where $\A$ is a third order tensor defined by the object itself and $\B$ is the third order tensor value defined by parameter B.
%@END

%@DOC:Tensor3::operator*(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator$\star$(double l)}}\label{Tensor3::operator*(double l)}\index[DL]{Tensor3!operator$\star$(double l)}\\
Multiplication of a third order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a third order tensor by a scalar value.
The result of this operation is also a third order tensor defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a third order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor3::operator/(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator/(double l)}}\label{Tensor3::operator/(double l)}\index[DL]{Tensor3!operator/(double l)}\\
Division of a third order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a third order tensor by a scalar value.
The result of this operation is also a third order tensor defined by:
\begin{equation*}
\T = \frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a third order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:operator*(double l, Tensor3 A)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{operator$\star$(double l, Tensor3 A)}}\label{operator*(double l, Tensor3 A)}\\
Multiplication of a third order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.\\
Tensor3 & A & Third order tensor to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a third order tensor by a scalar value.
The result of this operation is also a third order tensor defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a third order tensor and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor3::operator*(Vec3D V)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor3::operator$\star$(Vec3D V)}}\label{Tensor3::operator*(Vec3D V)}\index[DL]{Tensor3!operator$\star$(Vec3D V)}\\
Multiplication of a third order tensor by a vector.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & V & Vec3D to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a third order tensor by a vector.
The result of this operation is a second order tensor defined by:
\begin{equation*}
\B = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a third order tensor defined by the object itself and $\overrightarrow{x}$ is a Vec3D defined by parameter V.
%@END

\section{The Tensor4 class}

%@DOC:Tensor4::Tensor4
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::Tensor4}}\label{Tensor4::Tensor4}\index[DL]{Tensor4!Tensor4}\\
Second order tensor class.

The Tensor4 library is used to store fourth order tensors defined in the \DynELA.
The Tensor4 class is used to store and manage data relative to a fourth order tensor which can be seen as a $3\times3\times3\times3$ matrix where $T_{ijkl}$ are the components of the fourth order tensor $\T$.
Concerning the internal storage of data, the Tensor4 data is stored in a vector of $81$ components named \textsf{\_data} using the following storage scheme:
%@END



%@DOC:Tensor4::Tensor4()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::Tensor4(~)}}\label{Tensor4::Tensor4()}\index[DL]{Tensor4!Tensor4(~)}\\
Default constructor of the Tensor4 class.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : The new Tensor4 object created by the constructor.

This is the default constructor of the Tensor4 class, where all components are initialized to zero by default.
%@END

\subsection{Basic operations}

%@DOC:Tensor4::setToUnity()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::setToUnity(~)}}\label{Tensor4::setToUnity()}\index[DL]{Tensor4!setToUnity(~)}\\
Unity fourth order tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

This method transforms the current tensor to a fourth order unity tensor.
%@END

%@DOC:Tensor4::operator=(double v)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator=(double v)}}\label{Tensor4::operator=(double v)}\index[DL]{Tensor4!operator=(double v)}\\
Fill a fourth order tensor with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & v & Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the fourth order tensor class.
%@END

%@DOC:Tensor4::operator+(Tensor4 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator+(Tensor4 B)}}\label{Tensor4::operator+(Tensor4 B)}\index[DL]{Tensor4!operator+(Tensor4 B)}\\
Addition of 2 fourth order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor4 & B & Second order tensor to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 fourth order tensors.
The result of this operation is also a fourth order tensor defined by:
\begin{equation*}
\T = \A + \B
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\B$ is the fourth order tensor value defined by parameter B.
%@END

%@DOC:Tensor4::operator-(Tensor4 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator-(Tensor4 B)}}\label{Tensor4::operator-(Tensor4 B)}\index[DL]{Tensor4!operator-(Tensor4 B)}\\
Subtraction of 2 fourth order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor4 & B & Second order tensor to subtract to the current one.
\end{tcolorbox}

This method defines the subtraction of 2 fourth order tensors.
The result of this operation is also a fourth order tensor defined by:
\begin{equation*}
\T = \A - \B
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\B$ is the fourth order tensor value defined by parameter B.
%@END

%@DOC:Tensor4::operator*(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator$\star$(double l)}}\label{Tensor4::operator*(double l)}\index[DL]{Tensor4!operator$\star$(double l)}\\
Multiplication of a fourth order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a fourth order tensor by a scalar value.
The result of this operation is also a fourth order tensor defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor4::operator/(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator/(double l)}}\label{Tensor4::operator/(double l)}\index[DL]{Tensor4!operator/(double l)}\\
Division of a fourth order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a fourth order tensor by a scalar value.
The result of this operation is also a fourth order tensor defined by:
\begin{equation*}
\T = \frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:operator*(double l, Tensor4 A)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{operator$\star$(double l, Tensor4 A)}}\label{operator*(double l, Tensor4 A)}\\
Multiplication of a fourth order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.\\
Tensor4 & A & Second order tensor to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a fourth order tensor by a scalar value.
The result of this operation is also a fourth order tensor defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a fourth order tensor and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor4::operator*(Vec3D V)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator$\star$(Vec3D V)}}\label{Tensor4::operator*(Vec3D V)}\index[DL]{Tensor4!operator$\star$(Vec3D V)}\\
Multiplication of a fourth order tensor by a vector.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D & V & Vec3D to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a fourth order tensor by a vector.
The result of this operation is a third order tensor defined by:
\begin{equation*}
B = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\overrightarrow{x}$ is a Vec3D defined by parameter V.
%@END

%@DOC:Tensor4::operator*(Tensor2 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator$\star$(Tensor2 B)}}\label{Tensor4::operator*(Tensor2 B)}\index[DL]{Tensor4!operator$\star$(Tensor2 B)}\\
Multiplication of a fourth order tensor by a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & B & Tensor2 to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a fourth order tensor by a second order tensor.
The result of this operation is a second order tensor defined by:
\begin{equation*}
\C = \A \cdot \B
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\B$ is a Vesecond order tensor defined by parameter B.
%@END

%@DOC:Tensor4::operator+=(Tensor4 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator+=(Tensor4 B)}}\label{Tensor4::operator+=(Tensor4 B)}\index[DL]{Tensor4!operator+=(Tensor4 B)}\\
Addition of 2 fourth order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor4 & B & Second order tensor to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 fourth order tensors.
The result of this operation is also a fourth order tensor defined by:
\begin{equation*}
\A += \B
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\B$ is the fourth order tensor value defined by parameter B.
%@END

%@DOC:Tensor4::operator-=(Tensor4 B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator-=(Tensor4 B)}}\label{Tensor4::operator-=(Tensor4 B)}\index[DL]{Tensor4!operator-=(Tensor4 B)}\\
Difference of 2 fourth order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor4 & B & Second order tensor to add to the current one.
\end{tcolorbox}

This method defines the difference of 2 fourth order tensors.
The result of this operation is also a fourth order tensor defined by:
\begin{equation*}
\A -= \B
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\B$ is the fourth order tensor value defined by parameter B.
%@END

%@DOC:Tensor4::operator*=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator$\star$=(double l)}}\label{Tensor4::operator*=(double l)}\index[DL]{Tensor4!operator$\star$=(double l)}\\
Multiplication of a fourth order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a fourth order tensor by a scalar value.
The result of this operation is also a fourth order tensor defined by:
\begin{equation*}
\lambda \A
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Tensor4::operator/=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor4::operator/=(double l)}}\label{Tensor4::operator/=(double l)}\index[DL]{Tensor4!operator/=(double l)}\\
Division of a fourth order tensor by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4 : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a fourth order tensor by a scalar value.
The result of this operation is also a fourth order tensor defined by:
\begin{equation*}
\frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a fourth order tensor defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

\section{The Vector class}

%@DOC:Vector::Vector
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::Vector}}\label{Vector::Vector}\index[DL]{Vector!Vector}\\
Vector class.

This class is used to store information for Vectors.
This file is the declaration file for the Vector class. A Vector class is a vector with the following form:
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
  x_{1}\\
  x_{2}\\
  \vdots\\
  x_{n}
  \end{array}\right]
\end{equation*}
%@END

%@DOC:Vector::Vector(long l, double m)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::Vector(long l, double m)}}\label{Vector::Vector(long l, double m)}\index[DL]{Vector!Vector(long l, double m)}\\
Constructor of the Vector class with initialization.\\ \hspace*{10mm}$\hookrightarrow$ Vector : The initialized vector.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
long & l & Length of the vector to create.\\
double & m & Value to give to each element of the new vector.
\end{tcolorbox}

This method creates a new vector of length $l$ where all values are initialized to the scalar value $m$.
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
  x_{1}=m\\
  x_{2}=m\\
  \vdots\\
  x_{n}=m
  \end{array}\right]
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $m$ is scalar value defined by parameter m.
%@END

%@DOC:Vector::Vector(int l, double x1, double x2, ...)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::Vector(int l, double x1, double x2, ...)}}\label{Vector::Vector(int l, double x1, double x2, ...)}\index[DL]{Vector!Vector(int l, double x1, double x2, ...)}\\
Constructor of the vector class with initialization.\\ \hspace*{10mm}$\hookrightarrow$ Vector : The initialized vector.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
int & l & Number of components.\\
double & x1 & first component of the vector to create.\\
double & x2 & second component of the vector to create.\\
double & ... & $x^{th}$ component of the vector to create.
\end{tcolorbox}

All components have to be defined in col order.
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
  x_{1}=x1\\
  x_{2}=x2\\
  \vdots\\
  x_{n}=xn
  \end{array}\right]
\end{equation*}
%@END

\subsection{Basic operations}

%@DOC:Vector::size()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::size(~)}}\label{Vector::size()}\index[DL]{Vector!size(~)}\\
Returns the length of the vector.\\ \hspace*{10mm}$\hookrightarrow$ long : Length of the vector.

This method returns the length of the vector, \ie the number of components of the vector.
%@END

%@DOC:Vector::swap(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::swap(Vector y)}}\label{Vector::swap(Vector y)}\index[DL]{Vector!swap(Vector y)}\\
Swap the content of two vectors.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & y & Second vector for the swap operation.
\end{tcolorbox}

This method swaps the storage of two vectors.
The two vectors must have the exact same size.
%@END

%@DOC:Vector::redim(long s)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::redim(long s)}}\label{Vector::redim(long s)}\index[DL]{Vector!redim(long s)}\\
Change the allocation size of a vector.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method cleans the content of the vector.}

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
long & s & New allocation size of the vector after the operation.
\end{tcolorbox}

This method changes the size of a vector.
If the new size is the same as the actual size, this method does nothing.
%@END

%@DOC:Vector::resize(long s)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::resize(long s)}}\label{Vector::resize(long s)}\index[DL]{Vector!resize(long s)}\\
Change the size of a vector.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
long & s & New size of the vector after the operation.
\end{tcolorbox}

This method is used to specify a new vector dimension of the one given during initialization by the constructor.
This method makes a copy of the previous vector according to the new size, \ie it can shrink or expand the vector.
If the new vector size is greater than the previous one, zeros are added at the end of the vector.
%@END

%@DOC:Vector::printOut()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::printOut(~)}}\label{Vector::printOut()}\index[DL]{Vector!printOut(~)}\\
Displays the content of the vector on stdout.

This method displays the content of the vector on the screen in a predefined format.
The selection of the display format is made using the method setOutType().
The output type is defined by the variables listed in OutVector.
%@END

%@DOC:Vector::operator=(double v)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator=(double v)}}\label{Vector::operator=(double v)}\index[DL]{Vector!operator=(double v)}\\
Fill a vector with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ Vector

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & v & Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the vector class.
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
  x_{1}=v\\
  x_{2}=v\\
  \vdots\\
  x_{n}=v
  \end{array}\right]
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $v$ is the scalar value defined by parameter v.
%@END

%@DOC:Vector::norm()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::norm(~)}}\label{Vector::norm()}\index[DL]{Vector!norm(~)}\\
Returns the norm of a vector.\\ \hspace*{10mm}$\hookrightarrow$ double : The norm of the vector.

This method returns the norm $s$ of a vector $\overrightarrow{x}$ defined by:
\begin{equation*}
s = \left\Vert \overrightarrow{x} \right\Vert = \sqrt {x_{1}^2 + x_{2}^2 + ... + x_{n}^2}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself.
%@END

%@DOC:Vector::dot()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::dot(~)}}\label{Vector::dot()}\index[DL]{Vector!dot(~)}\\
Returns the dot product of a vector by itself.\\ \hspace*{10mm}$\hookrightarrow$ double : The dot product of the vector by itsefl.

This method returns dot product of a vector by itself defined by:
\begin{equation*}
 \left\Vert \overrightarrow{x} \right\Vert  = x_{1}^2 + x_{2}^2 + ... + x_{n}^2
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself.
%@END

%@DOC:Vector::dyadic()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::dyadic(~)}}\label{Vector::dyadic()}\index[DL]{Vector!dyadic(~)}\\
Dyadic product of a vector by itsefl.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : The matrix result of the dyadic product.

This method returns the dyadic product of two vectors defined by the following equation:
\begin{equation*}
\M = \overrightarrow{x}\otimes\overrightarrow{x},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
The result of this operation is a symmetric matrix.
%@END

%@DOC:Vector::dyadic(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::dyadic(Vector y)}}\label{Vector::dyadic(Vector y)}\index[DL]{Vector!dyadic(Vector y)}\\
Dyadic product of two Vector.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector&y&Vector $\overrightarrow{y}$ to use for the dyadic product operation.
\end{tcolorbox}

This method returns the dyadic product of two Vector defined by the following equation:
\begin{equation*}
\M = \overrightarrow{x}\otimes\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::normalize()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::normalize(~)}}\label{Vector::normalize()}\index[DL]{Vector!normalize(~)}\\
Normalize the Vector.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

This method modifies the given vector and makes its norm equal to $1$.
\begin{equation*}
\overrightarrow{x} = \frac{\overrightarrow{x}}{\sqrt {x_{1}^2 + x_{2}^2 + ... + x_{n}^2}}
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::maxVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::maxVal(~)}}\label{Vector::maxVal()}\index[DL]{Vector!maxVal(~)}\\
Maximum value in a vector.\\ \hspace*{10mm}$\hookrightarrow$ double : The maximum component of the vector.

This method returns the maximum value in a vector.
%@END

%@DOC:Vector::minVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::minVal(~)}}\label{Vector::minVal()}\index[DL]{Vector!minVal(~)}\\
Minumum value in a vector.\\ \hspace*{10mm}$\hookrightarrow$ double : The minimum component of the vector.

This method returns the minimum value in a vector.
%@END

%@DOC:Vector::maxAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::maxAbs(~)}}\label{Vector::maxAbs()}\index[DL]{Vector!maxAbs(~)}\\
Maximum absolute value in a vector.\\ \hspace*{10mm}$\hookrightarrow$ double : The maximum component of the vector.

This method returns the maximum absolute value in a vector.
%@END

%@DOC:Vector::minAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::minAbs(~)}}\label{Vector::minAbs()}\index[DL]{Vector!minAbs(~)}\\
Minumum absolute value in a vector.\\ \hspace*{10mm}$\hookrightarrow$ double : The minimum component of the vector.

This method returns the minimum absolute value in a vector.
%@END

%@DOC:Vector::distance(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::distance(Vector y)}}\label{Vector::distance(Vector y)}\index[DL]{Vector!distance(Vector y)}\\
Distance between two points.\\ \hspace*{10mm}$\hookrightarrow$ double : The distance.

This method computes the distance between two points using an Euclidian norm.
\begin{equation*}
d = \left\Vert \overrightarrow{y} - \overrightarrow{x} \right\Vert
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\overrightarrow{y}$ is the second vector of the operation.
%@END

%@DOC:Vector::squareDistance(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::squareDistance(Vector y)}}\label{Vector::squareDistance(Vector y)}\index[DL]{Vector!squareDistance(Vector y)}\\
Square of distance between two points.\\ \hspace*{10mm}$\hookrightarrow$ double : The distance.

This method computes the square of the distance between two points using an Euclidian norm.
\begin{equation*}
d = {\left\Vert \overrightarrow{y} - \overrightarrow{x} \right\Vert}^2
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\overrightarrow{y}$ is the second vector of the operation.
%@END

%@DOC:Vector::dot(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::dot(Vector y)}}\label{Vector::dot(Vector y)}\index[DL]{Vector!dot(Vector y)}\\
Dot product of two vectors.\\ \hspace*{10mm}$\hookrightarrow$ double : The dot product.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & y & Vector $\overrightarrow{y}$ to use for the dot product operation.
\end{tcolorbox}

This method returns the dot product of two vectors defined by the following equation:
\begin{equation*}
m = \overrightarrow{x}\cdot\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\overrightarrow{y}$ is given by the parameter y.
%@END

%@DOC:Vector::vectorProduct(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::vectorProduct(Vector y)}}\label{Vector::vectorProduct(Vector y)}\index[DL]{Vector!vectorProduct(Vector y)}\\
Vector product of two vectors.\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the operation.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method only works for two vectors with 3 components.}

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & y & Vector $\overrightarrow{y}$ to use for the vector product operation.
\end{tcolorbox}

This method returns the vector product of two Vector defined by the following equation:
\begin{equation*}
\overrightarrow{w} = \overrightarrow{x}\land\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself and $\overrightarrow{y}$ is given by the parameter y.
%@END

%@DOC:Vector::ewInverse()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::ewInverse(~)}}\label{Vector::ewInverse()}\index[DL]{Vector!ewInverse(~)}\\
Element-wise inverse of a vector\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the operation.

This method returns a vector containing the inverse of all elements of the vector.
\begin{equation*}
y_i = 1/x_i,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::ewExp()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::ewExp(~)}}\label{Vector::ewExp()}\index[DL]{Vector!ewExp(~)}\\
Element-wise exponential of a vector\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the operation.

This method returns a vector containing the exponential of all elements of the vector.
\begin{equation*}
y_i = \exp(x_i),
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::ewProduct(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::ewProduct(Vector y)}}\label{Vector::ewProduct(Vector y)}\index[DL]{Vector!ewProduct(Vector y)}\\
Element-wise product of two vectors.\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector&y&Vector $\overrightarrow{y}$ to use for the element-wise product operation.
\end{tcolorbox}

This method returns the vector product of two Vector defined by the following equation:
\begin{equation*}
w_i = x_i y_i,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::ewSquare()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::ewSquare(~)}}\label{Vector::ewSquare()}\index[DL]{Vector!ewSquare(~)}\\
Element-wise square of a vector\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the operation.

This method returns a vector containing the square of all elements of the vector.
\begin{equation*}
y_i = (x_i)^2,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::ewSquare(double m)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::ewSquare(double m)}}\label{Vector::ewSquare(double m)}\index[DL]{Vector!ewSquare(double m)}\\
Element-wise addition of a real to a vector\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&m&Value to add to all components of the vector
\end{tcolorbox}

This method returns a vector containing all elements of the given vector plus a quantity.
\begin{equation*}
y_i = x_i + m,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::setValue(double v)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::setValue(double v)}}\label{Vector::setValue(double v)}\index[DL]{Vector!setValue(double v)}\\
Fill a vector with a scalar value.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & v & Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the vector class.
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
  x_{1}=v\\
  x_{2}=v\\
  \vdots\\
  x_{n}=v
  \end{array}\right]
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $v$ is the scalar value defined by parameter v.
%@END

%@DOC:Vector::operator+(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator+(Vector y)}}\label{Vector::operator+(Vector y)}\index[DL]{Vector!operator+(Vector y)}\\
Addition of 2 vectors.\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & y & Vector to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 vectors.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{z}=\overrightarrow{x}+\overrightarrow{y}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\overrightarrow{y}$ is the second vector defined by parameter y.
%@END

%@DOC:Vector::operator+=(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator+=(Vector y)}}\label{Vector::operator+=(Vector y)}\index[DL]{Vector!operator+=(Vector y)}\\
Addition of 2 vectors.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & y & Vector to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 vectors.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{x}+=\overrightarrow{y}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\overrightarrow{y}$ is the second vector defined by parameter y.
%@END

%@DOC:Vector::operator-(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator-(Vector y)}}\label{Vector::operator-(Vector y)}\index[DL]{Vector!operator-(Vector y)}\\
Difference of 2 vectors.\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & y & Vector to subtract to the current one.
\end{tcolorbox}

This method defines the difference of 2 vectors.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{z}=\overrightarrow{x}-\overrightarrow{y}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\overrightarrow{y}$ is the second vector defined by parameter y.
%@END

%@DOC:Vector::operator-=(Vector y)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator-=(Vector y)}}\label{Vector::operator-=(Vector y)}\index[DL]{Vector!operator-=(Vector y)}\\
Difference of 2 vectors.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & y & Vector to subtract to the current one.
\end{tcolorbox}

This method defines the difference of 2 vectors.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{x}-=\overrightarrow{y}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\overrightarrow{y}$ is the second vector defined by parameter y.
%@END

%@DOC:Vector::operator-()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator-(~)}}\label{Vector::operator-()}\index[DL]{Vector!operator-(~)}\\
Opposite of a vector.\\ \hspace*{10mm}$\hookrightarrow$ Vector : The opposite vector.

This method defines the opposite of a vector.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = - \overrightarrow{x}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself.
%@END

%@DOC:Vector::operator*(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator$\star$(double l)}}\label{Vector::operator*(double l)}\index[DL]{Vector!operator$\star$(double l)}\\
Multiplication of a vector by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \lambda \overrightarrow{x}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Vector::operator*=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator$\star$=(double l)}}\label{Vector::operator*=(double l)}\index[DL]{Vector!operator$\star$=(double l)}\\
Multiplication of a vector by a scalar.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{x} *= \lambda
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Vector::operator/(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator/(double l)}}\label{Vector::operator/(double l)}\index[DL]{Vector!operator/(double l)}\\
Division of a vector by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \frac{1}{\lambda} \overrightarrow{x}
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Vector::operator/=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::operator/=(double l)}}\label{Vector::operator/=(double l)}\index[DL]{Vector!operator/=(double l)}\\
Division of a vector by a scalar.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} /= \lambda
\end{equation*}
where $\overrightarrow{x}$ is a vector defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Vector::getNormalized()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Vector::getNormalized(~)}}\label{Vector::getNormalized()}\index[DL]{Vector!getNormalized(~)}\\
Normalize the Vector.\\ \hspace*{10mm}$\hookrightarrow$  Vector : The result of the nomalization.

This method scales a vector and makes its norm equal to $1$.
\begin{equation*}
\overrightarrow{y} = \frac{\overrightarrow{x}}{\sqrt {x_{1}^2 + x_{2}^2 + ... + x_{n}^2}}
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END


\section{The Matrix classes}

\subsection{The Matrix class}

%@DOC:Matrix::Matrix
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::Matrix}}\label{Matrix::Matrix}\index[DL]{Matrix!Matrix}\\
Matrix class.

This class is used to store information for Matrices.
This file is the declaration file for the Matrix class. A Matrix class is a two dimensional object with size $n\times m$ with the following form:
\begin{equation*}
\M=\left[\begin{array}{cccc}
  M_{11} & M_{12} & \hdots & M_{1m}\\
  M_{21} & M_{21} & \hdots & M_{2m}\\
  \vdots & \vdots & \hdots & \vdots\\
  M_{n1} & M_{n1} & \hdots & M_{nm}
  \end{array}\right]
\end{equation*}
%@END

%@DOC:Matrix::Matrix(long r, long c, double m)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::Matrix(long r, long c, double m)}}\label{Matrix::Matrix(long r, long c, double m)}\index[DL]{Matrix!Matrix(long r, long c, double m)}\\
Constructor of the Matrix class with initialization.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : The initialized matrix.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
long & r & Number of rows of the matrix to create.\\
long & c & Number of cols of the matrix to create.\\
double & m & Value to give to each element of the new matrix.
\end{tcolorbox}

This method creates a new matrix of size $r \times c$ where all values are initialized to the scalar value $m$.
\begin{equation*}
\M=\left[\begin{array}{cccc}
  M_{11}=m & M_{12}=m & \hdots & M_{1c}=m\\
  M_{21}=m & M_{21}=m & \hdots & M_{2c}=m\\
  \vdots & \vdots & \hdots & \vdots\\
  M_{r1}=m & M_{r1}=m & \hdots & M_{rc}=m
  \end{array}\right]
\end{equation*}
where the $\M$ is the object itself and $m$ is scalar value defined by parameter m.
%@END

%@DOC:Matrix::Matrix(int r, int c, double x1, double x2, ...)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::Matrix(int r, int c, double x1, double x2, ...)}}\label{Matrix::Matrix(int r, int c, double x1, double x2, ...)}\index[DL]{Matrix!Matrix(int r, int c, double x1, double x2, ...)}\\
Constructor of the matrix class with initialization.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : The initialized matrix.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
int & r & Number of rows of the matrix to create.\\
int & c & Number of cols of the matrix to create.\\
double & x1 & first component of the matrix to create.\\
double & x2 & second component of the matrix to create.\\
double & ... & $x^{th}$ component of the matrix to create.
\end{tcolorbox}

All components have to be defined in row order.
\begin{equation*}
\M=\left[\begin{array}{cccc}
  M_{11}=x_1 & M_{12}=x_2 & \hdots & M_{1c}=x_c\\
  M_{21}=x_{c+1} & M_{21}=x_{c+2} & \hdots & M_{2c}=x_{2c}\\
  \vdots & \vdots & \hdots & \vdots\\
  M_{r1}=x_{(r-1)c+1} & M_{r1}=x_{(r-1)c+2} & \hdots & M_{rc}=x_{rc}
  \end{array}\right]
\end{equation*}
%@END

%@DOC:Matrix::redim(long r, long c)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::redim(long r, long c)}}\label{Matrix::redim(long r, long c)}\index[DL]{Matrix!redim(long r, long c)}\\
Change the allocation size of a matrix.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method cleans the content of the matrix.}

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
long & r & Number of rows of the matrix.\\
long & c & Number of cols of the matrix.
\end{tcolorbox}

This method changes the size of a matrix.
If the new size is the same as the actual size, this method does nothing.
%@END

\subsubsection{Basic operations}

%@DOC:Matrix::setValue(double v)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::setValue(double v)}}\label{Matrix::setValue(double v)}\index[DL]{Matrix!setValue(double v)}\\
Fill a matrix with a scalar value.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & v & Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the matrix class.
%@END

%@DOC:Matrix::transpose()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::transpose(~)}}\label{Matrix::transpose()}\index[DL]{Matrix!transpose(~)}\\
Transpose of a matrix.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : The transpose of the matrix.

This method defines the transpose of a matrix.
%@END

%@DOC:Matrix::operator=(double m)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator=(double m)}}\label{Matrix::operator=(double m)}\index[DL]{Matrix!operator=(double m)}\\
Fill a matrix with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ Matrix

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & m & Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the matrix class.
\begin{equation*}
\M=\left[\begin{array}{cccc}
  M_{11}=m & M_{12}=m & \hdots & M_{1c}=m\\
  M_{21}=m & M_{21}=m & \hdots & M_{2c}=m\\
  \vdots & \vdots & \hdots & \vdots\\
  M_{r1}=m & M_{r1}=m & \hdots & M_{rc}=m
  \end{array}\right]
\end{equation*}
where $\T$ is a matrix defined by the object itself and $m$ is the scalar value defined by parameter m.
%@END

%@DOC:Matrix::operator=(Tensor2 T)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator=(Tensor2 T)}}\label{Matrix::operator=(Tensor2 T)}\index[DL]{Matrix!operator=(Tensor2 T)}\\
Copy the content of a Tensor2 into a Matrix.\\ \hspace*{10mm}$\hookrightarrow$ Matrix

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2 & T & Second order tensor to copy.
\end{tcolorbox}

The result of this operation is a matrix as a copy of a second order tensor where $\T$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::operator+(Matrix B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator+(Matrix B)}}\label{Matrix::operator+(Matrix B)}\index[DL]{Matrix!operator+(Matrix B)}\\
Addition of 2 matrices.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Matrix & B & Matrix to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 matrices.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \A + \B
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\B$ is the matrix defined by parameter B.
%@END

%@DOC:Matrix::operator-(Matrix B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator-(Matrix B)}}\label{Matrix::operator-(Matrix B)}\index[DL]{Matrix!operator-(Matrix B)}\\
Difference of 2 matrices.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Matrix & B & Matrix to subtract to the current one.
\end{tcolorbox}

This method defines the difference of 2 matrices.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \A - \B
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\B$ is the matrix defined by parameter B.
%@END

%@DOC:Matrix::operator-()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator-(~)}}\label{Matrix::operator-()}\index[DL]{Matrix!operator-(~)}\\
Opposite of a matrix.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : The opposite matrix.

This method defines the opposite of a matrix.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = - \A
\end{equation*}
where $\A$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::operator+=(Matrix B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator+=(Matrix B)}}\label{Matrix::operator+=(Matrix B)}\index[DL]{Matrix!operator+=(Matrix B)}\\
Addition of 2 matrices.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the addition operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Matrix & B & Second matrix to add to the current one.
\end{tcolorbox}

This method defines the addition of 2 matrices.
The result of this operation is also a matrix defined by:
\begin{equation*}
\A += \B
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\B$ is the matrix defined by parameter B.
%@END

%@DOC:Matrix::operator-=(Matrix B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator-=(Matrix B)}}\label{Matrix::operator-=(Matrix B)}\index[DL]{Matrix!operator-=(Matrix B)}\\
Difference of 2 matrices.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the difference operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Matrix & B & Second matrix to add to the current one.
\end{tcolorbox}

This method defines the difference of 2 matrices.
The result of this operation is also a matrix defined by:
\begin{equation*}
\A -= \B
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\B$ is the matrix defined by parameter B.
%@END

%@DOC:Matrix::operator*(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator$\star$(double l)}}\label{Matrix::operator*(double l)}\index[DL]{Matrix!operator$\star$(double l)}\\
Multiplication of a matrix by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a matrix by a scalar value.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Matrix::operator*=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator$\star$=(double l)}}\label{Matrix::operator*=(double l)}\index[DL]{Matrix!operator$\star$=(double l)}\\
Multiplication of a matrix by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a matrix by a scalar value.
The result of this operation is also a matrix defined by:
\begin{equation*}
\lambda \A
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Matrix::operator/=(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator/=(double l)}}\label{Matrix::operator/=(double l)}\index[DL]{Matrix!operator/=(double l)}\\
Division of a matrix by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a matrix by a scalar value.
The result of this operation is also a matrix defined by:
\begin{equation*}
\frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Matrix::operator/(double l)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator/(double l)}}\label{Matrix::operator/(double l)}\index[DL]{Matrix!operator/(double l)}\\
Division of a matrix by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the division operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.
\end{tcolorbox}

This method defines the division of a matrix by a scalar value.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \frac{1}{\lambda} \A
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:operator*(double l, Matrix A)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{operator$\star$(double l, Matrix A)}}\label{operator*(double l, Matrix A)}\\
Multiplication of a matrix by a scalar.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & l & Scalar value to use for the operation.\\
Matrix & A & Second order tensor to use for the operation.
\end{tcolorbox}

This method defines the multiplication of a matrix by a scalar value.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \lambda \A
\end{equation*}
where $\A$ is a matrix and $\lambda$ is the scalar value defined by parameter l.
%@END

%@DOC:Matrix::operator*(Vector V)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator$\star$(Vector V)}}\label{Matrix::operator*(Vector V)}\index[DL]{Matrix!operator$\star$(Vector V)}\\
Multiplication of a matrix by a vector.\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & V & Vector to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a matrix by a vector.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\overrightarrow{x}$ is a Vector defined by parameter V.
This method uses the Blas \textsf{dgemv} Fortran subroutine to perform the operation.
%@END

\subsubsection{Specific operations}

%@DOC:Matrix::setToUnity()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::setToUnity(~)}}\label{Matrix::setToUnity()}\index[DL]{Matrix!setToUnity(~)}\\
Unity matrix.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This only works on a square matrix $n \times n$.}

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}} After the call to this method, the object is modified.

This method transforms the current matrix to a unity matrix.
\begin{equation*}
\M=\left[\begin{array}{cccc}
  M_{11}=1 & M_{12}=0 & \hdots & M_{1n}=0\\
  M_{21}=0 & M_{21}=1 & \hdots & M_{2n}=0\\
  \vdots & \vdots & \hdots & \vdots\\
  M_{n1}=0 & M_{n1}=0 & \hdots & M_{nn}=1
  \end{array}\right]
\end{equation*}
where $\M$ is a square matrix defined by the object itself.
%@END

%@DOC:Matrix::maxVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::maxVal(~)}}\label{Matrix::maxVal()}\index[DL]{Matrix!maxVal(~)}\\
Maximum component in a matrix.\\ \hspace*{10mm}$\hookrightarrow$ double : The maximum component of the matrix.

This method returns the maximum component in a matrix.
%@END

%@DOC:Matrix::minVal()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::minVal(~)}}\label{Matrix::minVal()}\index[DL]{Matrix!minVal(~)}\\
Minimum component in a matrix.\\ \hspace*{10mm}$\hookrightarrow$ double : The minimum component of the matrix.

This method returns the minimum component in a matrix.
%@END

%@DOC:Matrix::maxAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::maxAbs(~)}}\label{Matrix::maxAbs()}\index[DL]{Matrix!maxAbs(~)}\\
Maximum absolute component in a matrix.\\ \hspace*{10mm}$\hookrightarrow$ double : The maximum component of the matrix.

This method returns the maximum absolute component in a matrix.
%@END

%@DOC:Matrix::minAbs()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::minAbs(~)}}\label{Matrix::minAbs()}\index[DL]{Matrix!minAbs(~)}\\
Minimum absolute component in a matrix.\\ \hspace*{10mm}$\hookrightarrow$ double : The minimum component of the matrix.

This method returns the minimum absolute component in a matrix.
%@END

%@DOC:Matrix::trace()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::trace(~)}}\label{Matrix::trace()}\index[DL]{Matrix!trace(~)}\\
Returns the trace of a matrix.\\ \hspace*{10mm}$\hookrightarrow$ double : The trace of the matrix.

This method returns the trace of a matrix, i.e. the sum $s$ of all the terms of the diagonal:
\begin{equation*}
s = \tr[\M] = M_{11}+M_{22}+\hdots+M_{nn}
\end{equation*}
where $\M$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::averageTrace()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::averageTrace(~)}}\label{Matrix::averageTrace()}\index[DL]{Matrix!averageTrace(~)}\\
Returns the average trace of a matrix.\\ \hspace*{10mm}$\hookrightarrow$ double : The average trace of the matrix.

This method returns the average trace of a matrix, i.e. the sum $s$ of all the terms of the diagonal divided by the number of terms on the diagonal:
\begin{equation*}
s = \frac{1}{n} \tr[\M] = \frac{1}{n} M_{11}+M_{22}+\hdots+M_{nn}
\end{equation*}
where $\M$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::dot(Vector V)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::dot(Vector V)}}\label{Matrix::dot(Vector V)}\index[DL]{Matrix!dot(Vector V)}\\
Multiplication of a matrix by a vector.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}  The result of the operation is the parameter V itsefl.}

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & V & Vector to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a matrix by a vector.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\overrightarrow{x}$ is a Vector defined by parameter V.
This method uses the Blas \textsf{dgemv} Fortran subroutine to perform the operation.
%@END

%@DOC:Matrix::dotTxN(Vector V)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::dotTxN(Vector V)}}\label{Matrix::dotTxN(Vector V)}\index[DL]{Matrix!dotTxN(Vector V)}\\
Multiplication of a matrix by a vector.\\ \hspace*{10mm}$\hookrightarrow$ Vector : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & V & Vector to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a matrix by a vector.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \A^T \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\overrightarrow{x}$ is a Vector defined by parameter V.
This method uses the Blas \textsf{dgemv} Fortran subroutine to perform the operation.
%@END

%@DOC:Matrix::dot()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::dot(~)}}\label{Matrix::dot()}\index[DL]{Matrix!dot(~)}\\
Single contracted product of a matrix by itself.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the multiplication operation.

This method defines a single contracted product of a matrix by itself.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \A \cdot \A
\end{equation*}
where $\A$ is a matrix defined by the object itself.
This method uses the Blas \textsf{dgemm} Fortran subroutine to perform the operation.
%@END

%@DOC:Matrix::dotTxN()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::dotTxN(~)}}\label{Matrix::dotTxN()}\index[DL]{Matrix!dotTxN(~)}\\
Single contracted product of a matrix by its transpose.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the multiplication operation.

This method defines a single contracted product of a matrix by its transpose.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \A^T\cdot \A
\end{equation*}
where $\A$ is a matrix defined by the object itself. Result is a symmetric matrix.
This method uses the Blas \textsf{dgemm} Fortran subroutine to perform the operation.
%@END

%@DOC:Matrix::dotNxT()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::dotNxT(~)}}\label{Matrix::dotNxT()}\index[DL]{Matrix!dotNxT(~)}\\
Single contracted product of a matrix by its transpose.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the multiplication operation.

This method defines a single contracted product of a matrix by its transpose.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \A \cdot \A^T
\end{equation*}
where $\A$ is a matrix defined by the object itself. Result is a symmetric matrix.
This method uses the Blas \textsf{dgemm} Fortran subroutine to perform the operation.
%@END

%@DOC:Matrix::dot(Matrix B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::dot(Matrix B)}}\label{Matrix::dot(Matrix B)}\index[DL]{Matrix!dot(Matrix B)}\\
Single contracted product of two matrixs.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Matrix & B & Second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two matrixs.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\B$ is the matrix defined by parameter B.
This method uses the Blas \textsf{dgemm} Fortran subroutine to perform the operation.
%@END

%@DOC:Matrix::operator*(Matrix B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::operator$\star$(Matrix B)}}\label{Matrix::operator*(Matrix B)}\index[DL]{Matrix!operator$\star$(Matrix B)}\\
Single contracted product of two matrices.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Matrix & B & Second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two matrices.
The result of this operation is also a matrix defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\B$ is the matrix defined by parameter B.
%@END

%@DOC:Matrix::doubleDot()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::doubleDot(~)}}\label{Matrix::doubleDot()}\index[DL]{Matrix!doubleDot(~)}\\
Double contracted product of a matrix by itself.\\ \hspace*{10mm}$\hookrightarrow$ double : Result of the multiplication operation.

This method defines a double contracted product of a matrix by itself.
The result of this operation is a scalar $s$ defined by:
\begin{equation*}
s = \A : \A = \sum_{i=1}^{n} \sum_{j=1}^{m} A_{ij}\times A_{ij}
\end{equation*}
where $\A$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::doubleDot(Matrix B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::doubleDot(Matrix B)}}\label{Matrix::doubleDot(Matrix B)}\index[DL]{Matrix!doubleDot(Matrix B)}\\
Double contracted product of 2 matrices.\\ \hspace*{10mm}$\hookrightarrow$ double : Result of the multiplication operation.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Matrix & B & Second tensor for the multiplication operation.
\end{tcolorbox}

This method defines a double contracted product of two matrices.
The result of this operation is a scalar $s$ defined by:
\begin{equation*}
s = \A : \B = \sum_{i=1}^{n} \sum_{j=1}^{m} A_{ij}\times B_{ij}
\end{equation*}
where $\A$ is a matrix defined by the object itself and $\B$ is a matrix defined by parameter B.
%@END

%@DOC:Matrix::symmetric()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::symmetric(~)}}\label{Matrix::symmetric()}\index[DL]{Matrix!symmetric(~)}\\
Symmetric part of a matrix.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : The symmetric part of the matrix.

This method defines the symmetric part of a matrix with the following:
\begin{equation*}
\B = \frac{1}{2} \left( \A + \A^T \right)
\end{equation*}
where $\M$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::skewSymmetric()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::skewSymmetric(~)}}\label{Matrix::skewSymmetric()}\index[DL]{Matrix!skewSymmetric(~)}\\
Skew-symmetric part of a matrix.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : The skew-symmetric part of the matrix.

This method defines the skew-symmetric part of a matrix with the following:
\begin{equation*}
\B = \frac{1}{2} \left( \A - \A^T \right)
\end{equation*}
where $\M$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::row(short r)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::row(short r)}}\label{Matrix::row(short r)}\index[DL]{Matrix!row(short r)}\\
Extraction of a row from a matrix.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The extracted row.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short & r & Row to extract
\end{tcolorbox}

This method returns a vector as part of a matrix.
The result of this operation with the argument r is a vector defined by:
\begin{equation*}
v_{i} = T_{ri}
\end{equation*}
where $\T$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::col(short c)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::col(short c)}}\label{Matrix::col(short c)}\index[DL]{Matrix!col(short c)}\\
Extraction of a column from a matrix.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D : The extracted col.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short & c & Column to extract
\end{tcolorbox}

This method returns a vector as part of a matrix.
The result of this operation with the argument c is a vector defined by:
\begin{equation*}
v_{i} = T_{ic}
\end{equation*}
where $\T$ is a matrix defined by the object itself.
%@END

\subsubsection{Advanced operations}

%@DOC:Matrix::det()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::det(~)}}\label{Matrix::det()}\index[DL]{Matrix!det(~)}\\
Determinant of a matrix.\\ \hspace*{10mm}$\hookrightarrow$ double : The determinant.

This method returns the determinant of a matrix.
This method uses the Lapack \textsf{dgetrf} Fortran subroutine to perform the operation.
%@END

%@DOC:Matrix::det2()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::det2(~)}}\label{Matrix::det2()}\index[DL]{Matrix!det2(~)}\\
Determinant of a $2 \times 2$ matrix.\\ \hspace*{10mm}$\hookrightarrow$ double : The determinant.

This method returns the determinant of a $2 \times 2$ matrix.
The result of this operation is a scalar value defined by:
\begin{equation*}
d = T_{11} T_{22} - T_{21} T_{12}
\end{equation*}
where $\A$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::det3()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::det3(~)}}\label{Matrix::det3()}\index[DL]{Matrix!det3(~)}\\
Determinant of a $3 \times 3$ matrix.\\ \hspace*{10mm}$\hookrightarrow$ double : The determinant.

This method returns the determinant of a $3 \times 3$ matrix.
The result of this operation is a scalar value defined by:
\begin{equation*}
d = A_{11} A_{22} A_{33} + A_{21} A_{32} A_{13} + A_{31} A_{12} A_{23} - A_{31} A_{22} A_{13} - A_{11} A_{32} A_{23} - A_{21} A_{12} A_{33}
\end{equation*}
where $\A$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::cofactors()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::cofactors(~)}}\label{Matrix::cofactors()}\index[DL]{Matrix!cofactors(~)}\\
Cofactors of a matrix.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : The cofactor of the matrix.

This method returns the cofactor of a matrix defined by the following equation:
\begin{equation*}
\C = \det[\A] \cdot {\A^{-1}}^T
\end{equation*}
where $\T$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::computeInverse2x2(double d, Matrix B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::computeInverse2x2(double d, Matrix B)}}\label{Matrix::computeInverse2x2(double d, Matrix B)}\index[DL]{Matrix!computeInverse2x2(double d, Matrix B)}\\
Inverse of a matrix.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & d & The determinant of the matrix.\\
Matrix & B & The inverse of the matrix.
\end{tcolorbox}

This method returns the inverse of a $2 \times 2$ matrix.
The result of this operation is a $2 \times 2$ matrix defined by:
\begin{equation*}
A^{-1} = \frac {1}{d} \left[\begin{array}{cc}
  A_{22} & - A_{12}\\
  -A_{21} & A_{11}
  \end{array}
  \right]
\end{equation*}
where $\A$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::computeInverse3x3(double d, Matrix B)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::computeInverse3x3(double d, Matrix B)}}\label{Matrix::computeInverse3x3(double d, Matrix B)}\index[DL]{Matrix!computeInverse3x3(double d, Matrix B)}\\
Inverse of a matrix.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double & d & The determinant of the matrix.\\
Matrix & B & The inverse of the matrix.
\end{tcolorbox}

This method returns the inverse of a $3 \times 3$ matrix.
The result of this operation is a $3 \times 3$ matrix defined by:
\begin{equation*}
A^{-1} = \frac {1}{d} \left[\begin{array}{ccc}
  A_{22}A_{33}-A_{23}A_{32}&A_{13}A_{32}-A_{12}A_{33}&A_{12}A_{23}-A_{13}A_{22}\\
  A_{23}A_{31}-A_{21}A_{33}&A_{11}A_{33}-A_{13}A_{31}&A_{13}A_{21}-A_{11}A_{23}\\
  A_{21}A_{32}-A_{22}A_{31}&A_{12}A_{31}-A_{11}A_{32}&A_{11}A_{22}-A_{12}A_{21}
  \end{array}
  \right]
\end{equation*}
where $\A$ is a matrix defined by the object itself.
%@END

%@DOC:Matrix::inverse()
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::inverse(~)}}\label{Matrix::inverse()}\index[DL]{Matrix!inverse(~)}\\
Inverse of a matrix.\\ \hspace*{10mm}$\hookrightarrow$ Matrix : The inverse of the matrix.

This method returns the inverse of a matrix.
This method uses the Lapack \textsf{dgetrf} and \textsf{dgetri} Fortran subroutines to perform the operation.
%@END

%@DOC:Matrix::solve(Vector x)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::solve(Vector x)}}\label{Matrix::solve(Vector x)}\index[DL]{Matrix!solve(Vector x)}\\
Solves a linear system $\A\cdot \overrightarrow{x} = \overrightarrow{b}$.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :}  The result of the operation is the parameter x itsefl.}

This method returns the solution of a small linear system with the following form:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\overrightarrow{x}$ is a vector defined by parameter x.
This method uses the Lapack \textsf{dgesv} Fortran subroutine to perform the operation.
%@END

%@DOC:Matrix::getSolve(Vector x)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Matrix::getSolve(Vector x)}}\label{Matrix::getSolve(Vector x)}\index[DL]{Matrix!getSolve(Vector x)}\\
Solves a linear system $\A\cdot \overrightarrow{x} = \overrightarrow{b}$.\\ \hspace*{10mm}$\hookrightarrow$ Vector : The solution of the linear system.

This method returns the solution of a small linear system with the following form:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a second order tensor defined by the object itself and $\overrightarrow{x}$ is a vector defined by parameter x.
This method uses the Lapack \textsf{dgesv} Fortran subroutine to perform the operation.
%@END

%@DOC:Tensor2::computeSVD(Vector w, Matrix L, Matrix R)
% Automatic documentation generated from the DynELA source code
% Do not change anything in this LaTeX file between the @DOC and the @END keywords.
\textcolor{purple}{\textbf{Tensor2::computeSVD(Vector w, Matrix L, Matrix R)}}\label{Tensor2::computeSVD(Vector w, Matrix L, Matrix R)}\index[DL]{Tensor2!computeSVD(Vector w, Matrix L, Matrix R)}\\
Eigenvalues and eigenvactors of a $n \times m$ matrix.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector & w & Eigenvalues of the matrix\\
Matrix & L & Left eigenvector of the matrix\\
Matrix & T & Right eigenvector of the matrix
\end{tcolorbox}

This method computes the eigenvalues and the left and right eigenvectors of a $n \times m$ matrix
This method uses the Lapack \textsf{dgesvd} Fortran subroutine to perform the operation.
%@END

\subsection{The Diagonal Matrix class}

\section{The Function classes}

\subsection{The Discrete function class}

\subsection{The Polynomial function class}

\subsection{The Ramp function class}

\subsection{The Sinus function class}
