% !TeX spellcheck = en_US
% !TeX root = DynELA.tex
%
% LaTeX source file of DynELA FEM Code
%
% (c) by Olivier Pantal√© 2020
%
\chapter{DynELA Maths library}

\startcontents[chapters]
\printmyminitoc[2]\LETTRINE{T}he \DynELA~is an Explicit FEM code written in \Cpp~using a Python's interface for creating the Finite Element Models. 

\section{The Vec3D class}

%@DOC:Vec3D::Vec3D
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::Vec3D}}\label{Vec3D::Vec3D}\index[DL]{Vec3D!Vec3D}\\
Vec3D class.

This class is used to store information for Coordinate Vectors.
This file is the declaration file for the 3D vector class. A 3D vector class is a vector with the following form:
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
  x_{1}\\
  x_{2}\\
  x_{3}
  \end{array}\right]
\end{equation*}
%@END

\subsection{Constructors}

%@DOC:Vec3D::Vec3D(double x1, double x2, double x3)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::Vec3D(double x1, double x2, double x3)}}\label{Vec3D::Vec3D(double x1, double x2, double x3)}\index[DL]{Vec3D!Vec3D(double x1, double x2, double x3)}\\
Constructor of the Vec3D class with initialization.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&x1&first component of the Vec3D to create.\\
double&x2&second component of the Vec3D to create.\\
double&x3&third component of the Vec3D to create.
\end{tcolorbox}

%@END

%@DOC:Vec3D::Vec3D(Vec3D y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::Vec3D(Vec3D y)}}\label{Vec3D::Vec3D(Vec3D y)}\index[DL]{Vec3D!Vec3D(Vec3D y)}\\
Copy constructor of the Vec3D class.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D&y&Vec3D $\overrightarrow{y}$ to copy
\end{tcolorbox}

%@END

\subsection{Basic operations}

%@DOC:Vec3D::operator*(double val, Vec3D V)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::operator$\star$(double val, Vec3D V)}}\label{Vec3D::operator*(double val, Vec3D V)}\index[DL]{Vec3D!operator$\star$(double val, Vec3D V)}\\
Multiplication of a vector by a scalar value.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&val&Scalar value to use for the multiplication operation.\\
Vec3D&V&Vec3D to use for the multiplication operation.
\end{tcolorbox}

This method defines the multiplication of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \lambda \overrightarrow{x}
\end{equation*}
%@END

%@DOC:Vec3D::operator*(double val)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::operator$\star$(double val)}}\label{Vec3D::operator*(double val)}\index[DL]{Vec3D!operator$\star$(double val)}\\
Multiplication of a vector by a scalar value.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&val&Scalar value to use for the multiplication operation.
\end{tcolorbox}

This method defines the multiplication of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \lambda \overrightarrow{x}
\end{equation*}
%@END

%@DOC:Vec3D::operator/(double val)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::operator/(double val)}}\label{Vec3D::operator/(double val)}\index[DL]{Vec3D!operator/(double val)}\\
Division of a vector by a scalar value.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&val&Scalar value to use for the division operation.
\end{tcolorbox}

This method defines the division of a vector by a scalar value.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \frac{1}{\lambda}\overrightarrow{x}
\end{equation*}
%@END

%@DOC:Vec3D::maxValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::maxValue(~)}}\label{Vec3D::maxValue()}\index[DL]{Vec3D!maxValue(~)}\\
Maximum value in a Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum value in a Vec3D.
%@END

%@DOC:Vec3D::minValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::minValue(~)}}\label{Vec3D::minValue()}\index[DL]{Vec3D!minValue(~)}\\
Minumum value in a Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum value in a Vec3D.
%@END

%@DOC:Vec3D::maxmaxAbsoluteValueValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::maxmaxAbsoluteValueValue(~)}}\label{Vec3D::maxmaxAbsoluteValueValue()}\index[DL]{Vec3D!maxmaxAbsoluteValueValue(~)}\\
Maximum absolute value in a Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum absolute value in a Vec3D.
%@END

%@DOC:Vec3D::minAbsoluteValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::minAbsoluteValue(~)}}\label{Vec3D::minAbsoluteValue()}\index[DL]{Vec3D!minAbsoluteValue(~)}\\
Minumum absolute value in a Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum absolute value in a Vec3D.
%@END

%@DOC:Vec3D::dot(Vec3D y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::dot(Vec3D y)}}\label{Vec3D::dot(Vec3D y)}\index[DL]{Vec3D!dot(Vec3D y)}\\
Dot product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ double

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D&y&Vec3D $\overrightarrow{y}$ to use for the dot product operation.
\end{tcolorbox}

This method returns the dot product of two Vec3D defined by the following equation:
\begin{equation*}
m = \overrightarrow{x}\cdot\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vec3D::vectorProduct(Vec3D y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::vectorProduct(Vec3D y)}}\label{Vec3D::vectorProduct(Vec3D y)}\index[DL]{Vec3D!vectorProduct(Vec3D y)}\\
Vector product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D&y&Vec3D $\overrightarrow{y}$ to use for the vector product operation.
\end{tcolorbox}

This method returns the vector product of two Vec3D defined by the following equation:
\begin{equation*}
\overrightarrow{w} = \overrightarrow{x}\land\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vec3D::ewProduct(Vec3D y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::ewProduct(Vec3D y)}}\label{Vec3D::ewProduct(Vec3D y)}\index[DL]{Vec3D!ewProduct(Vec3D y)}\\
Element-wise product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D&y&Vec3D $\overrightarrow{y}$ to use for the element-wise product operation.
\end{tcolorbox}

This method returns the vector product of two Vec3D defined by the following equation:
\begin{equation*}
w_i = x_i y_i,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vec3D::ewProduct(Tensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::ewProduct(Tensor2 T)}}\label{Vec3D::ewProduct(Tensor2 T)}\index[DL]{Vec3D!ewProduct(Tensor2 T)}\\
Element-wise product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&y&Tensor2 $\overrightarrow{y}$ to use for the element-wise product operation.
\end{tcolorbox}

This method returns the vector product of a Vec3D and a Tensor2 defined by the following equation:
\begin{equation*}
A_{ij} = x_i T_{ij},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vec3D::dyadic(Vec3D y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::dyadic(Vec3D y)}}\label{Vec3D::dyadic(Vec3D y)}\index[DL]{Vec3D!dyadic(Vec3D y)}\\
Dyadic product of two Vec3D.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D&y&Vec3D $\overrightarrow{y}$ to use for the dyadic product operation.
\end{tcolorbox}

This method returns the dyadic product of two Vec3D defined by the following equation:
\begin{equation*}
\T = \overrightarrow{x}\otimes\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vec3D::dyadic()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::dyadic(~)}}\label{Vec3D::dyadic()}\index[DL]{Vec3D!dyadic(~)}\\
Dyadic product of a Vec3D by itsefl.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

This method returns the dyadic product of two Vec3D defined by the following equation:
\begin{equation*}
\T = \overrightarrow{x}\otimes\overrightarrow{x},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself. The result of this operation is a symmetric second order tensor.
%@END

%@DOC:Vec3D::dot()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::dot(~)}}\label{Vec3D::dot()}\index[DL]{Vec3D!dot(~)}\\
Returns the dot product of a Vec3D by itself.

This method returns dot product of a Vec3D by itself defined by:
\begin{equation*}
\left\Vert \overrightarrow{_data} \right\Vert  = v_{1}^2 + v_{2}^2 + v_{3}^2
\end{equation*}
%@END

%@DOC:Vec3D::normalize()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::normalize(~)}}\label{Vec3D::normalize()}\index[DL]{Vec3D!normalize(~)}\\
Get the normalized Vec3D.

This method returns a colinear Vec3D with a norm equal to $1$.
%@END

%@DOC:Vec3D::distance(Vec3D y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::distance(Vec3D y)}}\label{Vec3D::distance(Vec3D y)}\index[DL]{Vec3D!distance(Vec3D y)}\\
Distance between two points.

This method computes the distance between two points using an Euclidian getNorm.
\begin{equation*}
d = \left\Vert \overrightarrow{y} - \overrightarrow{x} \right\Vert 
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vec3D::squareDistance(Vec3D y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vec3D::squareDistance(Vec3D y)}}\label{Vec3D::squareDistance(Vec3D y)}\index[DL]{Vec3D!squareDistance(Vec3D y)}\\
Square of distance between two points.

This method computes the square of the distance between two points using an Euclidian getNorm.
\begin{equation*}
d = {\left\Vert \overrightarrow{y} - \overrightarrow{x} \right\Vert}^2 
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

\section{The Tensor2 class}

%@DOC:Tensor2::Tensor2
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::Tensor2}}\label{Tensor2::Tensor2}\index[DL]{Tensor2!Tensor2}\\
Second order tensor class.

The Tensor2 library is used to store second order tensors defined in the \DynELA. A second order tensor is a like a matrix with the following form:
\begin{equation*}
T=\left[\begin{array}{ccc}
  T_{11} & T_{12} & T_{13}\\
  T_{21} & T_{22} & T_{23}\\
  T_{31} & T_{32} & T_{33}
  \end{array}\right]
\end{equation*}
Concerning the internal storage of data, the Tensor2 data is stored in a vector of 9 components named \_data using the following storage scheme:
\begin{equation*}
T=\left[\begin{array}{ccc}
    T_{0} & T_{1} & T_{2}\\
    T_{3} & T_{4} & T_{5}\\
    T_{6} & T_{7} & T_{8}
    \end{array}\right]
\end{equation*}
%@END

\subsection{Constructors}
%@DOC:Tensor2::Tensor2()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::Tensor2(~)}}\label{Tensor2::Tensor2()}\index[DL]{Tensor2!Tensor2(~)}\\
Default constructor of the Tensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

All components are initialized to zero by default.
\begin{equation*}
\T=\left[\begin{array}{ccc}
0&0&0\\
0&0&0\\
0&0&0
\end{array}\right]
\end{equation*}
%@END

%@DOC:Tensor2::Tensor2(double,...)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::Tensor2(double,...)}}\label{Tensor2::Tensor2(double,...)}\index[DL]{Tensor2!Tensor2(double,...)}\\
Constructor of the Tensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&t1&Component $t_{11}$ of the tensor.\\
double&t2&Component $t_{12}$ of the tensor.\\
double&t3&Component $t_{13}$ of the tensor.\\
double&t4&Component $t_{21}$ of the tensor.\\
double&t5&Component $t_{22}$ of the tensor.\\
double&t6&Component $t_{23}$ of the tensor.\\
double&t7&Component $t_{31}$ of the tensor.\\
double&t8&Component $t_{32}$ of the tensor.\\
double&t9&Component $t_{33}$ of the tensor.
\end{tcolorbox}

Constructor of a second order tensor with explicit initialization of the 9 components of the tensor.
%@END

%@DOC:Tensor2::Tensor2(Tensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::Tensor2(Tensor2 T)}}\label{Tensor2::Tensor2(Tensor2 T)}\index[DL]{Tensor2!Tensor2(Tensor2 T)}\\
Copy constructor of the Tensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&T&Tensor to copy.
\end{tcolorbox}

%@END

%@DOC:Tensor2::operator=(SymTensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::operator=(SymTensor2 T)}}\label{Tensor2::operator=(SymTensor2 T)}\index[DL]{Tensor2!operator=(SymTensor2 T)}\\
Copy a SymTensor2 into a Tensor2.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&T&Symmetric tensor 2 to copy.
\end{tcolorbox}

%@END

\subsection{Basic operations}

%@DOC:Tensor2::setToZero()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::setToZero(~)}}\label{Tensor2::setToZero()}\index[DL]{Tensor2!setToZero(~)}\\
Sets all components of the tensor to zero.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method modifies its own argument}

\begin{equation*}
\T=\left[\begin{array}{ccc}
0&0&0\\
0&0&0\\
0&0&0
\end{array}\right]
\end{equation*}
%@END

%@DOC:Tensor2::setToUnity()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::setToUnity(~)}}\label{Tensor2::setToUnity()}\index[DL]{Tensor2!setToUnity(~)}\\
Unity tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method modifies its own argument}

This method transforms the current tensor to a unity tensor.
\begin{equation*}
\T=\left[\begin{array}{ccc}
1&0&0\\
0&1&0\\
0&0&1
\end{array}\right]
\end{equation*}
%@END

%@DOC:Tensor2::getTranspose()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getTranspose(~)}}\label{Tensor2::getTranspose()}\index[DL]{Tensor2!getTranspose(~)}\\
Transpose of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

This method defines the transpose of a second second order tensor.
The result of this operation is a second order tensor defined by the following equation:
\begin{equation*}
\A=\B^T =\left[\begin{array}{ccc}
  B_{11} & B_{21} & B_{31}\\
  B_{12} & B_{22} & B_{32}\\
  B_{13} & B_{23} & B_{33}
  \end{array}\right]
\end{equation*}
%@END

%@DOC:Tensor2::operator=(double val)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::operator=(double val)}}\label{Tensor2::operator=(double val)}\index[DL]{Tensor2!operator=(double val)}\\
Fill a second order tensor with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&val&Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the second order tensor class.
\begin{equation*}
\T=\left[\begin{array}{ccc}
m&m&m\\
m&m&m\\
m&m&m
\end{array}\right]
\end{equation*}
%@END

%@DOC:Tensor2::rowSum()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::rowSum(~)}}\label{Tensor2::rowSum()}\index[DL]{Tensor2!rowSum(~)}\\
Sum of the rows of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

This method returns a vector by computing the sum of the components on all rows of a second second order tensor.
The result of this operation is a vector defined by:
\begin{equation*}
v_{i}=\sum_{j=1}^{3} T_{ji}
\end{equation*}
%@END

%@DOC:Tensor2::columnSum()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::columnSum(~)}}\label{Tensor2::columnSum()}\index[DL]{Tensor2!columnSum(~)}\\
Sum of the columns of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

This method returns a vector by computing the sum of the components on all columns of a second second order tensor.
The result of this operation is a vector defined by:
\begin{equation*}
v_{i}=\sum_{j=1}^{3}T_{ij}
\end{equation*}
%@END

%@DOC:Tensor2::getRow(short row)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getRow(short row)}}\label{Tensor2::getRow(short row)}\index[DL]{Tensor2!getRow(short row)}\\
Extraction of a row from a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short&row&Row to extract
\end{tcolorbox}

This method returns a vector as part of a second second order tensor.
The result of this operation with the argument j is a vector defined by:
\begin{equation*}
v_{i} = T_{ij}
\end{equation*}
%@END

%@DOC:Tensor2::getColumn(short col)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getColumn(short col)}}\label{Tensor2::getColumn(short col)}\index[DL]{Tensor2!getColumn(short col)}\\
Extraction of a column from a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short&col&Column to extract
\end{tcolorbox}

This method returns a vector as part of a second second order tensor.
The result of this operation with the argument j is a vector defined by:
\begin{equation*}
v_{i} = T_{ji}
\end{equation*}
%@END

%@DOC:Tensor2::minValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::minValue(~)}}\label{Tensor2::minValue()}\index[DL]{Tensor2!minValue(~)}\\
Minimum component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum component in a second second order tensor.
%@END

%@DOC:Tensor2::minAbsoluteValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::minAbsoluteValue(~)}}\label{Tensor2::minAbsoluteValue()}\index[DL]{Tensor2!minAbsoluteValue(~)}\\
Minimum absolute component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum absolute component in a second second order tensor.
%@END

%@DOC:Tensor2::maxValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::maxValue(~)}}\label{Tensor2::maxValue()}\index[DL]{Tensor2!maxValue(~)}\\
Maximum component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum component in a second second order tensor.
%@END

%@DOC:Tensor2::maxAbsoluteValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::maxAbsoluteValue(~)}}\label{Tensor2::maxAbsoluteValue()}\index[DL]{Tensor2!maxAbsoluteValue(~)}\\
Maximum absolute component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum absolute component in a second second order tensor.
%@END

%@DOC:Tensor2::getTrace()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getTrace(~)}}\label{Tensor2::getTrace()}\index[DL]{Tensor2!getTrace(~)}\\
Returns the trace of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

  This method returns the trace of a second order tensor, i.e. the sum of all the terms of the diagonal:
\begin{equation*}
v = tr[\T] = T_{11}+T_{22}+T_{33}
\end{equation*}
%@END

%@DOC:Tensor2::getThirdTrace()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getThirdTrace(~)}}\label{Tensor2::getThirdTrace()}\index[DL]{Tensor2!getThirdTrace(~)}\\
Returns the average value of the trace of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns average value of the trace of a second order tensor, i.e. the sum of all the terms of the diagonal divided by 3:
\begin{equation*}
v = \frac{1}{3} tr[\T] =  \frac{1}{3} \left( T_{11}+T_{22}+T_{33} \right)
\end{equation*}
%@END

\subsection{Specific operations}

%@DOC:Tensor2::singleProduct(Tensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::singleProduct(Tensor2 T)}}\label{Tensor2::singleProduct(Tensor2 T)}\index[DL]{Tensor2!singleProduct(Tensor2 T)}\\
Contracted product of two second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&T&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ and $\B$ are two second order tensors.
%@END

%@DOC:Tensor2::singleProduct()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::singleProduct(~)}}\label{Tensor2::singleProduct()}\index[DL]{Tensor2!singleProduct(~)}\\
Contracted product of a second order tensor by itself.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

This method defines a single contracted product of of a second order tensor by itself.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \A
\end{equation*}
where $\A$ is a two second order tensor.
%@END

%@DOC:Tensor2::singleProductTxN()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::singleProductTxN(~)}}\label{Tensor2::singleProductTxN()}\index[DL]{Tensor2!singleProductTxN(~)}\\
Contracted product of a second order tensor by its transpose.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

This method defines a single contracted product of two second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A^T\cdot \A
\end{equation*}
where $\A$ is a second order tensor. Result is a symmetric second order tensor.
%@END

%@DOC:Tensor2::singleProductNxT()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::singleProductNxT(~)}}\label{Tensor2::singleProductNxT()}\index[DL]{Tensor2!singleProductNxT(~)}\\
Contracted product of a second order tensor by its transpose.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

This method defines a single contracted product of two second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \A^T
\end{equation*}
where $\A$ is a second order tensor. Result is a symmetric second order tensor.
%@END

%@DOC:Tensor2::operator*(Tensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::operator$\star$(Tensor2 T)}}\label{Tensor2::operator*(Tensor2 T)}\index[DL]{Tensor2!operator$\star$(Tensor2 T)}\\
Multiplication of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&T&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ and $\B$ are two second order tensors.
%@END

%@DOC:Tensor2::operator*(SymTensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::operator$\star$(SymTensor2 T)}}\label{Tensor2::operator*(SymTensor2 T)}\index[DL]{Tensor2!operator$\star$(SymTensor2 T)}\\
Multiplication of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&T&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ is a second order tensor and $\B$ is a symmetric second order tensor.
%@END

%@DOC:Tensor2::doubleProduct(Tensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::doubleProduct(Tensor2 T)}}\label{Tensor2::doubleProduct(Tensor2 T)}\index[DL]{Tensor2!doubleProduct(Tensor2 T)}\\
Double contracted product of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ double

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&T&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines a double contracted product of two second order tensors.
The result of this operation is a scalar defined by:
\begin{equation*}
s = \A : \B = \sum_{i=1}^{3} \sum_{j=1}^{3} A_{ij}\times B_{ij}
\end{equation*}
where $\A$ and $\B$ are two second order tensors.
%@END

%@DOC:Tensor2::doubleProduct()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::doubleProduct(~)}}\label{Tensor2::doubleProduct()}\index[DL]{Tensor2!doubleProduct(~)}\\
Double contracted product of a second order tensor by itself.\\ \hspace*{10mm}$\hookrightarrow$ double

This method defines a double contracted product of a second order tensor by itself.
The result of this operation is a scalar defined by:
\begin{equation*}
s = \A : \A = \sum_{i=1}^{3} \sum_{j=1}^{3} A_{ij}\times A_{ij}
\end{equation*}
where $\A$ is a second order tensor.
%@END

%@DOC:Tensor2::operator*(Vec3D V)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::operator$\star$(Vec3D V)}}\label{Tensor2::operator*(Vec3D V)}\index[DL]{Tensor2!operator$\star$(Vec3D V)}\\
Multiplication of a second order tensor by a vector.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D&V&Vec3D to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a second order tensor by a vector.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a second order tensor and $\overrightarrow{x}$ and $\overrightarrow{y}$ are two Vec3D.
%@END

%@DOC:Tensor2::getDeviator()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getDeviator(~)}}\label{Tensor2::getDeviator()}\index[DL]{Tensor2!getDeviator(~)}\\
Deviatoric part of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

This method defines the deviatoric part of a second second order tensor.
The result of this operation is a second order tensor defined by the following equation:
\begin{equation*}
\Sig^d=\Sig-\frac{1}{3}\tr[\Sig].\Id
\end{equation*}
where $\Sig^d$ is the deviatoric part of the tensor, $\Sig$ is the tensor and $\Id$ is the unit tensor.
%@END

%@DOC:Tensor2::getSymetricPart()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getSymetricPart(~)}}\label{Tensor2::getSymetricPart()}\index[DL]{Tensor2!getSymetricPart(~)}\\
Symmetric part of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

This method returns the symmetric part of a second second order tensor.
The result of this operation is a second second order tensor defined by:
\begin{equation*}
\B = \left[\begin{array}{ccc}
 A_{11} & \frac{A_{12} + A_{21}}{2} & \frac{A_{13} + A_{31}}{2}\\
 \frac{A_{12} + A_{21}}{2} & A_{22} & \frac {A_{23} + A_{32}}{2}\\
 \frac{A_{13} + A_{31}}{2} & \frac {A_{23} + A_{32}}{2} & A_{33}\end{array}
\right]
\end{equation*}
%@END

%@DOC:Tensor2::getSkewSymetricPart()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getSkewSymetricPart(~)}}\label{Tensor2::getSkewSymetricPart()}\index[DL]{Tensor2!getSkewSymetricPart(~)}\\
Skew-symmetric part of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

This method returns the skew-symmetric part of a second second order tensor.
The result of this operation is a second second order tensor defined by:
\begin{equation*}
\B = \left[\begin{array}{ccc}
 A_{11} & \frac{A_{12} - A_{21}}{2} & \frac{A_{13} - A_{31}}{2}\\
 -\frac{A_{12} -  A_{21}}{2} & A_{22} & \frac {A_{23} - A_{32}}{2}\\
 -\frac{A_{13} - A_{31}}{2} & -\frac {A_{23} - A_{32}}{2} & A_{33}\end{array}
\right]
\end{equation*}
%@END

%@DOC:Tensor2::getDeterminant()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getDeterminant(~)}}\label{Tensor2::getDeterminant()}\index[DL]{Tensor2!getDeterminant(~)}\\
Determinant of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the determinant of a second second order tensor.
The result of this operation is a scalar value defined by:
\begin{equation*}
D = T_{11} T_{22} T_{33} + T_{21} T_{32} T_{13} + T_{31} T_{12} T_{23} - T_{31} T_{22} T_{13} - T_{11} T_{32} T_{23} - T_{21} T_{12} T_{33}
\end{equation*}
%@END

%@DOC:Tensor2::inverse()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::inverse(~)}}\label{Tensor2::inverse()}\index[DL]{Tensor2!inverse(~)}\\
Inverse of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

This method returns the inverse of a second second order tensor.
The result of this operation is a second order tensor defined by:
\begin{equation*}
D = T_{11} T_{22} T_{33} + T_{21} T_{32} T_{13} + T_{31} T_{12} T_{23} - T_{31} T_{22} T_{13} - T_{11} T_{32} T_{23} - T_{21} T_{12} T_{33}
\end{equation*}
\begin{equation*}
T^{-1} = \frac {1}{D} \left[\begin{array}{ccc}
  T_{22}T_{33}-T_{23}T_{32}&T_{13}T_{32}-T_{12}T_{33}&T_{12}T_{23}-T_{13}T_{22}\\
  T_{23}T_{31}-T_{21}T_{33}&T_{11}T_{33}-T_{13}T_{31}&T_{13}T_{21}-T_{11}T_{23}\\
  T_{21}T_{32}-T_{22}T_{31}&T_{12}T_{31}-T_{11}T_{32}&T_{11}T_{22}-T_{12}T_{21}
  \end{array}
  \right]
\end{equation*}
%@END

%@DOC:Tensor2::getNorm()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getNorm(~)}}\label{Tensor2::getNorm()}\index[DL]{Tensor2!getNorm(~)}\\
Norm of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the norm of a second order tensor defined by:\begin{equation*}
\left\Vert s \right\Vert  = \sqrt {s_{ij}:s_{ij}}
\end{equation*}
%@END

%@DOC:Tensor2::getJ2()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::getJ2(~)}}\label{Tensor2::getJ2()}\index[DL]{Tensor2!getJ2(~)}\\
J2 norm of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the J2 norm of a second order tensor defined by:
\begin{equation*}
\sqrt {\frac{3}{2}} \left\Vert s \right\Vert  = \sqrt {\frac{3}{2} s_{ij}:s_{ij}}
\end{equation*}
%@END

\subsection{Advanced operations}

%@DOC:Tensor2::polarQL(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polarQL(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarQL(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarQL(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the QL with implicit shifts algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\U$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
%@END

%@DOC:Tensor2::polarQLLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polarQLLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarQLLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarQLLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the QL with implicit shifts algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
%@END

%@DOC:Tensor2::polarCuppen(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polarCuppen(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarCuppen(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarCuppen(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Cuppen‚Äôs Divide and Conquer algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\U$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
%@END

%@DOC:Tensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarCuppenLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Cuppen‚Äôs Divide and Conquer algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
%@END

%@DOC:Tensor2::polarJacobi(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polarJacobi(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarJacobi(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarJacobi(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\U$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
%@END

%@DOC:Tensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarJacobiLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
%@END

%@DOC:Tensor2::polarLapack(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polarLapack(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarLapack(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarLapack(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\U$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
It uses the LAPACKE\_dgeev function of the Lapack library which is far from efficient for a trivial 3x3 matrix. So this method is very slow.
%@END

%@DOC:Tensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarLapackLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
It uses the LAPACKE\_dgeev function of the Lapack library which is far from efficient for a trivial 3x3 matrix. So this method is very slow.
%@END

%@DOC:Tensor2::polar(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polar(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polar(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polar(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the old \DynELA algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
%@END

%@DOC:Tensor2::polarLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor2::polarLnU(SymTensor2 U, Tensor2 R)}}\label{Tensor2::polarLnU(SymTensor2 U, Tensor2 R)}\index[DL]{Tensor2!polarLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the old \DynELA algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\U$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
%@END

\begin{tcolorbox}[width=0.95\textwidth,myTab,tabularx={l||C|C|C},title=Performance of the polar algorithms]%,boxrule=0.5pt]
 & $\U$ version& $\log[\U]$ & Precision\\
 & CPU (ns) & CPU (ns) & $\F-\R\cdot\U$\\\hline\hline
polarLapack & $2163$ & $2360$ & $1.4210\times10^{-14}$ \\\hline
polar & $397$ & $432$ & $3.5527\times10^{-15}$\\\hline
polarQL & $246$ & $292$ & $1.0658\times10^{-14}$\\\hline
polarJacobi & $368$ & $390$ & $5.3291\times10^{-15}$\\\hline
polarCuppen & $234$ & $243$ & $3.5527\times10^{-15}$
\end{tcolorbox}

\section{The Symmetric Tensor2 class}

%@DOC:SymTensor2::SymTensor2
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::SymTensor2}}\label{SymTensor2::SymTensor2}\index[DL]{SymTensor2!SymTensor2}\\
Second order tensor class.

The SymTensor2 library is used to store symmetric second order tensors defined in the \DynELA. A symmetric second order tensor is a like a matrix with the following form:
\begin{equation*}
T=\left[\begin{array}{ccc}
  T_{11} & T_{12} & T_{13}\\
  T_{12} & T_{22} & T_{23}\\
  T_{13} & T_{23} & T_{33}
  \end{array}\right]
\end{equation*}
Concerning the internal storage of data, the SymTensor2 data is stored in a vector \_data of 6 components using the following storage scheme:
\begin{equation*}
T=\left[\begin{array}{ccc}
    T_{0} & T_{1} & T_{2}\\
    T_{1} & T_{3} & T_{4}\\
    T_{2} & T_{4} & T_{5}
    \end{array}\right]
\end{equation*}
%@END

\subsection{Constructors}

%@DOC:SymTensor2::SymTensor2()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::SymTensor2(~)}}\label{SymTensor2::SymTensor2()}\index[DL]{SymTensor2!SymTensor2(~)}\\
Default constructor of the SymTensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

All components are initialized to zero by default.
\begin{equation*}
\T=\left[\begin{array}{ccc}
0&0&0\\
0&0&0\\
0&0&0
\end{array}\right]
\end{equation*}
%@END

%@DOC:SymTensor2::SymTensor2(double,...)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::SymTensor2(double,...)}}\label{SymTensor2::SymTensor2(double,...)}\index[DL]{SymTensor2!SymTensor2(double,...)}\\
Constructor of the SymTensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&t1&Component $t_{11}$ of the tensor.\\
double&t2&Component $t_{12}$ of the tensor.\\
double&t3&Component $t_{13}$ of the tensor.\\
double&t4&Component $t_{22}$ of the tensor.\\
double&t5&Component $t_{23}$ of the tensor.\\
double&t6&Component $t_{33}$ of the tensor.
\end{tcolorbox}

Constructor of a second order symmetric tensor with explicit initialization of the 6 components of the tensor.
%@END

%@DOC:SymTensor2::SymTensor2(SymTensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::SymTensor2(SymTensor2 T)}}\label{SymTensor2::SymTensor2(SymTensor2 T)}\index[DL]{SymTensor2!SymTensor2(SymTensor2 T)}\\
Copy constructor of the SymTensor2 class.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&T&Tensor to copy.
\end{tcolorbox}

%@END

\subsection{Basic operations}

%@DOC:SymTensor2::setToZero()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::setToZero(~)}}\label{SymTensor2::setToZero()}\index[DL]{SymTensor2!setToZero(~)}\\
Sets all components of the tensor to zero.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method modifies its own argument}

\begin{equation*}
\T=\left[\begin{array}{ccc}
0&0&0\\
0&0&0\\
0&0&0
\end{array}\right]
\end{equation*}
%@END

%@DOC:SymTensor2::setToUnity()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::setToUnity(~)}}\label{SymTensor2::setToUnity()}\index[DL]{SymTensor2!setToUnity(~)}\\
Unity tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method modifies its own argument}

This method transforms the current tensor to a unity tensor.
\begin{equation*}
\T=\left[\begin{array}{ccc}
1&0&0\\
0&1&0\\
0&0&1
\end{array}\right]
\end{equation*}
%@END

%@DOC:SymTensor2::operator=(double val)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::operator=(double val)}}\label{SymTensor2::operator=(double val)}\index[DL]{SymTensor2!operator=(double val)}\\
Fill a second order tensor with a scalar value.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&val&Value to use for the operation.
\end{tcolorbox}

This method is a surdefinition of the = operator for the symmetric second order tensor class.
\begin{equation*}
\T=\left[\begin{array}{ccc}
m&m&m\\
m&m&m\\
m&m&m
\end{array}\right]
\end{equation*}
%@END

%@DOC:SymTensor2::rowSum()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::rowSum(~)}}\label{SymTensor2::rowSum()}\index[DL]{SymTensor2!rowSum(~)}\\
Sum of the rows of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

This method returns a vector by computing the sum of the components on all rows of a second second order tensor.
The result of this operation is a vector defined by:
\begin{equation*}
v_{i}=\sum_{j=1}^{3} T_{ji}
\end{equation*}
%@END

%@DOC:SymTensor2::columnSum()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::columnSum(~)}}\label{SymTensor2::columnSum()}\index[DL]{SymTensor2!columnSum(~)}\\
Sum of the columns of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

This method returns a vector by computing the sum of the components on all columns of a second second order tensor.
The result of this operation is a vector defined by:
\begin{equation*}
v_{i}=\sum_{j=1}^{3}T_{ij}
\end{equation*}
%@END

%@DOC:SymTensor2::getRow(short row)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::getRow(short row)}}\label{SymTensor2::getRow(short row)}\index[DL]{SymTensor2!getRow(short row)}\\
Extraction of a row from a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short&row&Row to extract
\end{tcolorbox}

This method returns a vector as part of a second second order tensor.
The result of this operation with the argument j is a vector defined by:
\begin{equation*}
v_{i} = T_{ij}
\end{equation*}
%@END

%@DOC:SymTensor2::getColumn(short col)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::getColumn(short col)}}\label{SymTensor2::getColumn(short col)}\index[DL]{SymTensor2!getColumn(short col)}\\
Extraction of a column from a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
short&col&Column to extract
\end{tcolorbox}

This method returns a vector as part of a second second order tensor.
The result of this operation with the argument j is a vector defined by:
\begin{equation*}
v_{i} = T_{ji}
\end{equation*}
%@END

%@DOC:SymTensor2::minValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::minValue(~)}}\label{SymTensor2::minValue()}\index[DL]{SymTensor2!minValue(~)}\\
Minimum component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum component in a second second order tensor.
%@END

%@DOC:SymTensor2::minAbsoluteValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::minAbsoluteValue(~)}}\label{SymTensor2::minAbsoluteValue()}\index[DL]{SymTensor2!minAbsoluteValue(~)}\\
Minimum absolute component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum absolute component in a second second order tensor.
%@END

%@DOC:SymTensor2::maxValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::maxValue(~)}}\label{SymTensor2::maxValue()}\index[DL]{SymTensor2!maxValue(~)}\\
Maximum component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum component in a second second order tensor.
%@END

%@DOC:SymTensor2::maxAbsoluteValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::maxAbsoluteValue(~)}}\label{SymTensor2::maxAbsoluteValue()}\index[DL]{SymTensor2!maxAbsoluteValue(~)}\\
Maximum absolute component in a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum absolute component in a second second order tensor.
%@END

%@DOC:SymTensor2::getTrace()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::getTrace(~)}}\label{SymTensor2::getTrace()}\index[DL]{SymTensor2!getTrace(~)}\\
Returns the trace of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

  This method returns the trace of a symmetric second order tensor, i.e. the sum of all the terms of the diagonal:
\begin{equation*}
v = tr[\T] = T_{11}+T_{22}+T_{33}
\end{equation*}
%@END

%@DOC:SymTensor2::getThirdTrace()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::getThirdTrace(~)}}\label{SymTensor2::getThirdTrace()}\index[DL]{SymTensor2!getThirdTrace(~)}\\
Returns the average value of the trace of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns average value of the trace of a symmetric second order tensor, i.e. the sum of all the terms of the diagonal divided by 3:
\begin{equation*}
v = \frac{1}{3} tr[\T] =  \frac{1}{3} \left( T_{11}+T_{22}+T_{33} \right)
\end{equation*}
%@END

\subsection{Specific operations}

%@DOC:SymTensor2::singleProduct(SymTensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::singleProduct(SymTensor2 T)}}\label{SymTensor2::singleProduct(SymTensor2 T)}\index[DL]{SymTensor2!singleProduct(SymTensor2 T)}\\
Contracted product of two symmetric second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&T&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two symmetric second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T=A \cdot \B=\left[\begin{array}{ccc}
A_{11} B_{11} + A_{12} B_{12} + A_{13} B_{13} & A_{11} B_{12} + A_{12} B_{22} + A_{13} B_{23} & A_{11} B_{13} + A_{12} B_{23} + A_{13} B_{33} \\
A_{12} B_{11} + A_{22} B_{12} + A_{23} B_{13} & A_{12} B_{12} + A_{22} B_{22} + A_{23} B_{23} & A_{12} B_{13} + A_{22} B_{23} + A_{23} B_{33} \\
A_{13} B_{11} + A_{23} B_{12} + A_{33} B_{13} & A_{13} B_{12} + A_{23} B_{22} + A_{33} B_{23} & A_{13} B_{13} + A_{23} B_{23} + A_{33} B_{33}
\end{array}\right]
\end{equation*}
where $\A$ and $\B$ are two symmetric second order tensors, the result is a non symmetric second order tensor.
%@END

%@DOC:SymTensor2::singleProduct()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::singleProduct(~)}}\label{SymTensor2::singleProduct()}\index[DL]{SymTensor2!singleProduct(~)}\\
Contracted product of a symmetric second order tensor by itself.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

This method defines a single contracted product of of a symmetric second order tensor by itself.
The result of this operation is also a symmetric second order tensor defined by:
\begin{equation*}
\T = \A \cdot \A
\end{equation*}
where $\A$ is a two symmetric second order tensor.
%@END

%@DOC:SymTensor2::operator*(SymTensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::operator$\star$(SymTensor2 T)}}\label{SymTensor2::operator*(SymTensor2 T)}\index[DL]{SymTensor2!operator$\star$(SymTensor2 T)}\\
Multiplication of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&T&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two symmetric second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\A$ and $\B$ are two symmetric second order tensors.
%@END

%@DOC:SymTensor2::operator*(Tensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::operator$\star$(Tensor2 T)}}\label{SymTensor2::operator*(Tensor2 T)}\index[DL]{SymTensor2!operator$\star$(Tensor2 T)}\\
Multiplication of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&T&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines a single contracted product of two symmetric second order tensors.
The result of this operation is also a second order tensor defined by:
\begin{equation*}
\T = \A \cdot \B
\end{equation*}
where $\B$ is a second order tensor and $\A$ is a symmetric second order tensor.
%@END

%@DOC:SymTensor2::doubleProduct(SymTensor2 T)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::doubleProduct(SymTensor2 T)}}\label{SymTensor2::doubleProduct(SymTensor2 T)}\index[DL]{SymTensor2!doubleProduct(SymTensor2 T)}\\
Double contracted product of 2 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ double

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&T&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines a double contracted product of two symmetric second order tensors.
The result of this operation is a scalar defined by:
\begin{equation*}
s = \A : \B = \sum_{i=1}^{3} \sum_{j=1}^{3} A_{ij}\times B_{ij}
\end{equation*}
where $\A$ and $\B$ are two symmetric second order tensors.
%@END

%@DOC:SymTensor2::doubleProduct()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::doubleProduct(~)}}\label{SymTensor2::doubleProduct()}\index[DL]{SymTensor2!doubleProduct(~)}\\
Double contracted product of a second order tensor by itself.\\ \hspace*{10mm}$\hookrightarrow$ double

This method defines a double contracted product of a second order tensor by itself.
The result of this operation is a scalar defined by:
\begin{equation*}
s = \A : \A = \sum_{i=1}^{3} \sum_{j=1}^{3} A_{ij}\times A_{ij}
\end{equation*}
where $\A$ is a second order tensor.
%@END

%@DOC:SymTensor2::operator*(Vec3D V)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::operator$\star$(Vec3D V)}}\label{SymTensor2::operator*(Vec3D V)}\index[DL]{SymTensor2!operator$\star$(Vec3D V)}\\
Multiplication of a symmetric second order tensor by a vector.\\ \hspace*{10mm}$\hookrightarrow$ Vec3D

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vec3D&V&Vec3D to use for the multiplication operation.
\end{tcolorbox}

This method defines the product of a symmetric second order tensor by a vector.
The result of this operation is also a vector defined by:
\begin{equation*}
\overrightarrow{y} = \A \cdot \overrightarrow{x}
\end{equation*}
where $\A$ is a symmetric second order tensor and $\overrightarrow{x}$ and $\overrightarrow{y}$ are two Vec3D.
%@END

%@DOC:SymTensor2::getDeviator()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::getDeviator(~)}}\label{SymTensor2::getDeviator()}\index[DL]{SymTensor2!getDeviator(~)}\\
Deviatoric part of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

This method defines the deviatoric part of a second second order tensor.
The result of this operation is a second order tensor defined by the following equation:
\begin{equation*}
\Sig^d=\Sig-\frac{1}{3}\tr[\Sig].\Id
\end{equation*}
where $\Sig^d$ is the deviatoric part of the tensor, $\Sig$ is the tensor and $\Id$ is the unit tensor.
%@END

%@DOC:SymTensor2::getDeterminant()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::getDeterminant(~)}}\label{SymTensor2::getDeterminant()}\index[DL]{SymTensor2!getDeterminant(~)}\\
Determinant of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the determinant of a symmetric second second order tensor.
The result of this operation is a scalar value defined by:
\begin{equation*}
D = T_{11} T_{22} T_{33} + 2 T_{12} T_{23} T_{13} - T_{22} T_{13}^2 - T_{11} T_{23}^2 - T_{33} T_{12}^2
\end{equation*}
%@END

%@DOC:SymTensor2::inverse()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::inverse(~)}}\label{SymTensor2::inverse()}\index[DL]{SymTensor2!inverse(~)}\\
Inverse of a second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2

This method returns the inverse of a second second order tensor.
The result of this operation is a second order tensor defined by:
\begin{equation*}
D = T_{11} T_{22} T_{33} + 2 T_{12} T_{23} T_{13} - T_{22} T_{13}^2 - T_{11} T_{23}^2 - T_{33} T_{12}^2
\end{equation*}
\begin{equation*}
T^{-1} = \frac {1}{D} \left[\begin{array}{ccc}
  T_{22}T_{33}-T_{23}^2&T_{13}T_{23}-T_{12}T_{33}&T_{12}T_{23}-T_{13}T_{22}\\
  T_{13}T_{23}-T_{12}T_{33}&T_{11}T_{33}-T_{13}^2&T_{12}T_{13}-T_{11}T_{23}\\
  T_{12}T_{23}-T_{13}T_{22}&T_{12}T_{13}-T_{11}T_{23}&T_{11}T_{22}-T_{12}^2
  \end{array}
  \right]
\end{equation*}
%@END

%@DOC:SymTensor2::getNorm()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::getNorm(~)}}\label{SymTensor2::getNorm()}\index[DL]{SymTensor2!getNorm(~)}\\
Norm of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the norm of a symmetric second order tensor defined by:
\begin{equation*}
\left\Vert s \right\Vert  = \sqrt {s_{ij}:s_{ij}}
\end{equation*}
%@END

%@DOC:SymTensor2::getJ2()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::getJ2(~)}}\label{SymTensor2::getJ2()}\index[DL]{SymTensor2!getJ2(~)}\\
J2 norm of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the J2 norm of a symmetric second order tensor defined by:
\begin{equation*}
\sqrt {\frac{3}{2}} \left\Vert s \right\Vert  = \sqrt {\frac{3}{2} s_{ij}:s_{ij}}
\end{equation*}
%@END

%@DOC:SymTensor2::getMisesEquivalent()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::getMisesEquivalent(~)}}\label{SymTensor2::getMisesEquivalent()}\index[DL]{SymTensor2!getMisesEquivalent(~)}\\
Returns the von Mises stress of a symmetric second order tensor.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the von Mises stress of a symmetric second order tensor defined by:
\begin{equation*}
\overline{\sigma} = \frac {1}{\sqrt{2}}\sqrt{(s_{11}-s_{22})^2+(s_{22}-s_{33})^2+(s_{33}-s_{11})^2+6(s_{12}^2+s_{23}^2+s_{31}^2)}
\end{equation*}
%@END

\subsection{Advanced operations}

%@DOC:SymTensor2::productByRxRT(Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::productByRxRT(Tensor2 R)}}\label{SymTensor2::productByRxRT(Tensor2 R)}\index[DL]{SymTensor2!productByRxRT(Tensor2 R)}\\
Special combination for a multiplication of 3 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&R&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines the product of a symmetric tensor by two rotations defined by the following equation:
\begin{equation*}
\R = \Q \cdot \A \cdot \Q^T =\left[\begin{array}{ccc}
R_0&R_1&R_2\\
&R_3&R_4\\
&&R_5
\end{array}\right]
\end{equation*}
with:
\begin{align*}
R_0&=A_0 Q_0^2 + 2 (A_1 Q_1 + A_2 Q_2)Q_0 + A_3 Q_1^2 + 2 A_4 Q_1 Q_2 + A_5 Q_2^2\\
R_1&=(A_0 Q_3 + A_1 Q_4 + A_2 Q_5)Q_0 + (A_1 Q_3 + A_3 Q_4 + A_4 Q_5)Q_1 + (A_2 Q_3 + A_4 Q_4 + A_5 Q_5)Q_2\\
R_2&= (A_0 Q_6 + A_1 Q_7 + A_2 Q_8)Q_0 + (A_1 Q_6 + A_3 Q_7 + A_4 Q_8)Q_1 + (A_2 Q_6 + A_4 Q_7 + A_5 Q_8)Q_2\\
R_3&=A_0 Q_3^2 + 2 (A_1 Q_4 + A_2 Q_5)Q_3+ A_3 Q_4^2 + 2 A_4 Q_4 Q_5 + A_5 Q_5^2\\
R_4&= (A_0 Q_6 + A_1 Q_7 + A_2 Q_8)Q_3 + (A_1 Q_6 + A_3 Q_7 + A_4 Q_8)Q_4 + (A_2 Q_6 + A_4 Q_7 + A_5 Q_8)Q_5\\
R_5&=A_0 Q_6^2 + 2 (A_1 Q_7 + A_2 Q_8)Q_6+ A_3 Q_7^2 + 2 A_4 Q_7 Q_8 + A_5 Q_8^2
\end{align*}
where $\A$ is a symmetric second order tensor and $\Q$ an orthogonal tensor.
%@END

%@DOC:SymTensor2::productByRTxR(Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::productByRTxR(Tensor2 R)}}\label{SymTensor2::productByRTxR(Tensor2 R)}\index[DL]{SymTensor2!productByRTxR(Tensor2 R)}\\
Special combination for a multiplication of 3 second order tensors.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Tensor2&R&Second Tensor for the multiplication operation.
\end{tcolorbox}

This method defines the product of a symmetric tensor by two rotations defined by the following equation:
\begin{equation*}
\R = \Q^T \cdot \A \cdot \Q =\left[\begin{array}{ccc}
R_0&R_1&R_2\\
&R_3&R_4\\
&&R_5
\end{array}\right]
\end{equation*}
with:
\begin{align*}
R_0 &= A_0 Q_0^2 + 2 (A_1 Q_3 + A_2 Q_6) Q_0 + A_3 Q_3^2 + 2 A_4 Q_3 Q_6 + A_5 Q_6^2 \\
R_1 &= A_1 Q_1 Q_3 +A_2 Q_1 Q_6 + (A_0 Q_1 + A_1 Q_4 + A_2 Q_7) Q_0+ A_3 Q_3 Q_4 + A_4 Q_4 Q_6 + A_4 Q_3 Q_7 + A_5 Q_6 Q_7\\
R_2 &= A_1 Q_2 Q_3 + A_2 Q_2 Q_6 + Q_0 (A_0 Q_2 + A_1 Q_5 + A_2 Q_8) + A_3 Q_3 Q_5 + A_4 Q_5 Q_6 + A_4 Q_3 Q_8 + A_5 Q_6 Q_8\\
R_3 &= A_0 Q_1^2 + 2 (A_1 Q_4 + A_2 Q_7)Q_1 + A_3 Q_4^2 + 2 A_4 Q_4 Q_7 + A_5 Q_7^2\\
R_4 &= A_1 Q_2 Q_4 + A_2 Q_2 Q_7 + (A_0 Q_2 + A_1 Q_5 + A_2 Q_8)Q_1 + A_3 Q_4 Q_5 + A_4 Q_5 Q_7 + A_4 Q_4 Q_8 + A_5 Q_7 Q_8\\
R_5 &= A_0 Q_2^2 + 2 (A_1 Q_5 + A_2 Q_8) Q_2 + A_3 Q_5^2 + 2 A_4 Q_5 Q_8 + A_5 Q_8^2
\end{align*}
where $\A$ is a symmetric second order tensor and $\Q$ an orthogonal tensor.
%@END

%@DOC:SymTensor2::polarQL(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polarQL(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarQL(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarQL(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the QL with implicit shifts algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\U$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
%@END

%@DOC:SymTensor2::polarQLLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polarQLLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarQLLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarQLLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the QL with implicit shifts algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
%@END

%@DOC:SymTensor2::polarCuppen(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polarCuppen(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarCuppen(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarCuppen(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Cuppen‚Äôs Divide and Conquer algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
%@END

%@DOC:SymTensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarCuppenLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarCuppenLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Cuppen‚Äôs Divide and Conquer algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
%@END

%@DOC:SymTensor2::polarJacobi(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polarJacobi(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarJacobi(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarJacobi(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
%@END

%@DOC:SymTensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarJacobiLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarJacobiLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
%@END

%@DOC:SymTensor2::polarLapack(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polarLapack(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarLapack(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarLapack(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
It uses the LAPACKE\_dgeev function of the Lapack library which is far from efficient for a trivial 3x3 matrix. So this method is very slow.
%@END

%@DOC:SymTensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarLapackLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarLapackLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the Jacobi algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
It uses the LAPACKE\_dgeev function of the Lapack library which is far from efficient for a trivial 3x3 matrix. So this method is very slow.
%@END

%@DOC:SymTensor2::polar(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polar(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polar(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polar(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the old \DynELA algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\U$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
%@END

%@DOC:SymTensor2::polarLnU(SymTensor2 U, Tensor2 R)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{SymTensor2::polarLnU(SymTensor2 U, Tensor2 R)}}\label{SymTensor2::polarLnU(SymTensor2 U, Tensor2 R)}\index[DL]{SymTensor2!polarLnU(SymTensor2 U, Tensor2 R)}\\
Polar decomposition of a second order tensor using the old \DynELA algorithm.\\ \hspace*{10mm}$\hookrightarrow$ SymTensor2 and Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
SymTensor2&U&Symmetric tensor $\log[\U]$\\
Tensor2&R&Rotation tensor $\R$
\end{tcolorbox}

This method computes the polar decomposition of a second order tensor $\F$ and returns the symmetric tensor $\R$ and the tensor $\log[\U]$ so that:
\begin{equation*}
\F = \R \cdot \U
\end{equation*}
\begin{equation*}
\log [\U] =\sum _{i=1}^{3}\log[\lambda_{i}](\overrightarrow{u}_{i}\otimes \overrightarrow{u}_{i})
\end{equation*}
%@END

\begin{tcolorbox}[width=0.95\textwidth,myTab,tabularx={l||C|C|C},title=Performance of the polar algorithms for symmetric tensors]%,boxrule=0.5pt]
 & $\U$ version& $\log[\U]$ & Precision\\
 & CPU (ns) & CPU (ns) & $\F-\R\cdot\U$\\\hline\hline
polarLapack & $2441$ & $2151$& $1.4210\times10^{-14}$ \\\hline
polar & $435$ & $436$& $3.5527\times10^{-15}$\\\hline
polarQL & $260$ & $281$& $1.0658\times10^{-14}$\\\hline
polarJacobi & $350$ & $356$ & $5.3291\times10^{-15}$\\\hline
polarCuppen & $206$ & $233$& $3.5527\times10^{-15}$
\end{tcolorbox}

\section{The Tensor3 class}

The Tensor3 library is used to store third order tensors defined in the \DynELA.

%@DOC:Tensor3::Tensor3()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor3::Tensor3(~)}}\label{Tensor3::Tensor3()}\index[DL]{Tensor3!Tensor3(~)}\\
This method is the default constructor of a third order tensor.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3

All components are initialized to zero by default.
%@END

%@DOC:Tensor3::Tensor3(Tensor3)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor3::Tensor3(Tensor3)}}\label{Tensor3::Tensor3(Tensor3)}\index[DL]{Tensor3!Tensor3(Tensor3)}\\
Copy constructor of the Tensor3 class.\\ \hspace*{10mm}$\hookrightarrow$ Tensor3

%@END

%@DOC:Tensor3::setToUnity()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor3::setToUnity(~)}}\label{Tensor3::setToUnity()}\index[DL]{Tensor3!setToUnity(~)}\\
Returns an identity third order tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method modifies its own argument}

This method transforms the current tensor to a unity tensor.
%@END

\section{The Tensor4 class}

The Tensor4 library is used to store fourth order tensors defined in the \DynELA.

%@DOC:Tensor4::Tensor4()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor4::Tensor4(~)}}\label{Tensor4::Tensor4()}\index[DL]{Tensor4!Tensor4(~)}\\
Default constructor of the TenTensor4sor2 class.\\ \hspace*{10mm}$\hookrightarrow$ Tensor4

All components are initialized to zero by default.
%@END

%@DOC:Tensor4::setToUnity()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Tensor4::setToUnity(~)}}\label{Tensor4::setToUnity()}\index[DL]{Tensor4!setToUnity(~)}\\
Unity tensor.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method modifies its own argument}

This method transforms the current tensor to a unity tensor.
%@END

\section{The Vector class}

%@DOC:Vector::Vector
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::Vector}}\label{Vector::Vector}\index[DL]{Vector!Vector}\\
Vector class.

This class is used to store information for Vectors.
This file is the declaration file for the Vector class. A Vector class is a vector with the following form:
\begin{equation*}
\overrightarrow{x}=\left[\begin{array}{c}
  x_{1}\\
  x_{2}\\
  \vdots\\
  x_{n}
  \end{array}\right]
\end{equation*}
%@END

\subsection{Constructors}

%@DOC:Vector::size()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::size(~)}}\label{Vector::size()}\index[DL]{Vector!size(~)}\\
Returns the length of the vector.\\ \hspace*{10mm}$\hookrightarrow$ long

This method returns the length of the vector, \ie the number of components of the vector.
%@END

%@DOC:Vector::Vector(long l, double x)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::Vector(long l, double x)}}\label{Vector::Vector(long l, double x)}\index[DL]{Vector!Vector(long l, double x)}\\
Constructor of the Vector class with initialization.\\ \hspace*{10mm}$\hookrightarrow$ Vector

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
long&l&Length of the vector to create.\\
double&x&Value to give to each element of the new vector.
\end{tcolorbox}

This method creates a new vector of length $l$ where all values are initialized to $x$.
%@END

%@DOC:Vector::Vector(Vector y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::Vector(Vector y)}}\label{Vector::Vector(Vector y)}\index[DL]{Vector!Vector(Vector y)}\\
Copy constructor of the Vec3D class.\\ \hspace*{10mm}$\hookrightarrow$ Vector

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector&y&Vector $\overrightarrow{y}$ to copy
\end{tcolorbox}

%@END

%@DOC:Vector::Vector(int l, double x1, double x2, ...)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::Vector(int l, double x1, double x2, ...)}}\label{Vector::Vector(int l, double x1, double x2, ...)}\index[DL]{Vector!Vector(int l, double x1, double x2, ...)}\\
Constructor of the Vector class with initialization.\\ \hspace*{10mm}$\hookrightarrow$ Vector

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
int&l&Number of components.\\
double&x1&first component of the Vector to create.\\
double&x2&second component of the Vector to create.
\end{tcolorbox}

%@END

\subsection{Basic operations}

%@DOC:Vector::swap(Vector y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::swap(Vector y)}}\label{Vector::swap(Vector y)}\index[DL]{Vector!swap(Vector y)}\\
Swap the content of two vectors.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector&y&Second vector for the swap operation.
\end{tcolorbox}

This method swaps the storage of two vectors. The two vectors must have the exact same size.
%@END

%@DOC:Vector::redim(long s)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::redim(long s)}}\label{Vector::redim(long s)}\index[DL]{Vector!redim(long s)}\\
Change the allocation size of a vector.

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method cleans the content of the vector.}

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
long&s&New allocation size of the vector after the operation.
\end{tcolorbox}

This method changes the size of a vector.
%@END

%@DOC:Vector::resize(long s)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::resize(long s)}}\label{Vector::resize(long s)}\index[DL]{Vector!resize(long s)}\\
Change the size of a vector.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
long&s&New size of the vector after the operation.
\end{tcolorbox}

This method is used to specify a new vector dimension of the one given during initialization by the constructor.
This method makes a copy of the previous vector according to the new size, \ie it can shrink or expand the vector.
If the new vector size is greater than the previous one, zeros are added at the end of the vector.
%@END

%@DOC:Vector::printOut()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::printOut(~)}}\label{Vector::printOut()}\index[DL]{Vector!printOut(~)}\\
Displays the content of the vector on stdout.

This method displays the content of the vector on the screen in a predefined format.
The selection of the display format is made using the method setOutType().
The output type is defined by the variables listed in OutVector.
%@END

%@DOC:Vector::setToValue(double val)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::setToValue(double val)}}\label{Vector::setToValue(double val)}\index[DL]{Vector!setToValue(double val)}\\
This method affect a value to a vector.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&val&Scalar value to use for the  operation.
\end{tcolorbox}

%@END

%@DOC:Vector::operator=(double val)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::operator=(double val)}}\label{Vector::operator=(double val)}\index[DL]{Vector!operator=(double val)}\\
This method affect a value to a vector.

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&val&Scalar value to use for the  operation.
\end{tcolorbox}

%@END

%@DOC:Vector::getNorm()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::getNorm(~)}}\label{Vector::getNorm()}\index[DL]{Vector!getNorm(~)}\\
Returns the norm of a vector.

This method returns norm of a vector defined by:
\begin{equation*}
\left\Vert \overrightarrow{v} \right\Vert = \sqrt {v_{1}^2 + v_{2}^2 + ... + v_{n}^2}
\end{equation*}
%@END

%@DOC:Vector::dot()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::dot(~)}}\label{Vector::dot()}\index[DL]{Vector!dot(~)}\\
Returns the dot product of a vector by itself.

This method returns dot product of a vector by itself defined by:
\begin{equation*}
 \left\Vert \overrightarrow{v} \right\Vert  = v_{1}^2 + v_{2}^2 + ... + v_{n}^2
\end{equation*}
%@END

%@DOC:Vector::dyadic()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::dyadic(~)}}\label{Vector::dyadic()}\index[DL]{Vector!dyadic(~)}\\
Dyadic product of a Vector by itsefl.\\ \hspace*{10mm}$\hookrightarrow$ Matrix

This method returns the dyadic product of two Vector defined by the following equation:
\begin{equation*}
\M = \overrightarrow{x}\otimes\overrightarrow{x},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself. The result of this operation is a symmetric second order tensor.
%@END

%@DOC:Vector::dyadic(Vector y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::dyadic(Vector y)}}\label{Vector::dyadic(Vector y)}\index[DL]{Vector!dyadic(Vector y)}\\
Dyadic product of two Vector.\\ \hspace*{10mm}$\hookrightarrow$ Tensor2

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector&y&Vector $\overrightarrow{y}$ to use for the dyadic product operation.
\end{tcolorbox}

This method returns the dyadic product of two Vector defined by the following equation:
\begin{equation*}
\M = \overrightarrow{x}\otimes\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::normalize()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::normalize(~)}}\label{Vector::normalize()}\index[DL]{Vector!normalize(~)}\\
Get the normalized Vector.

This method returns a colinear vector with a norm equal to $1$.
%@END

%@DOC:Vector::maxValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::maxValue(~)}}\label{Vector::maxValue()}\index[DL]{Vector!maxValue(~)}\\
Maximum value in a Vector.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum value in a Vector.
%@END

%@DOC:Vector::minValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::minValue(~)}}\label{Vector::minValue()}\index[DL]{Vector!minValue(~)}\\
Minumum value in a Vector.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum value in a Vector.
%@END

%@DOC:Vector::maxmaxAbsoluteValueValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::maxmaxAbsoluteValueValue(~)}}\label{Vector::maxmaxAbsoluteValueValue()}\index[DL]{Vector!maxmaxAbsoluteValueValue(~)}\\
Maximum absolute value in a Vector.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the maximum absolute value in a Vector.
%@END

%@DOC:Vector::minAbsoluteValue()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::minAbsoluteValue(~)}}\label{Vector::minAbsoluteValue()}\index[DL]{Vector!minAbsoluteValue(~)}\\
Minumum absolute value in a Vector.\\ \hspace*{10mm}$\hookrightarrow$ double

This method returns the minimum absolute value in a Vector.
%@END

%@DOC:Vector::distance(Vector y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::distance(Vector y)}}\label{Vector::distance(Vector y)}\index[DL]{Vector!distance(Vector y)}\\
Distance between two points.

This method computes the distance between two points using an Euclidian getNorm.
\begin{equation*}
d = \left\Vert \overrightarrow{y} - \overrightarrow{x} \right\Vert
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::squareDistance(Vector y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::squareDistance(Vector y)}}\label{Vector::squareDistance(Vector y)}\index[DL]{Vector!squareDistance(Vector y)}\\
Square of distance between two points.

This method computes the square of the distance between two points using an Euclidian getNorm.
\begin{equation*}
d = {\left\Vert \overrightarrow{y} - \overrightarrow{x} \right\Vert}^2
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::dot(Vector y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::dot(Vector y)}}\label{Vector::dot(Vector y)}\index[DL]{Vector!dot(Vector y)}\\
Dot product of two Vector.\\ \hspace*{10mm}$\hookrightarrow$ double

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector&y&Vector $\overrightarrow{y}$ to use for the dot product operation.
\end{tcolorbox}

This method returns the dot product of two Vector defined by the following equation:
\begin{equation*}
m = \overrightarrow{x}\cdot\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::vectorProduct(Vector y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::vectorProduct(Vector y)}}\label{Vector::vectorProduct(Vector y)}\index[DL]{Vector!vectorProduct(Vector y)}\\
Vector product of two Vector.\\ \hspace*{10mm}$\hookrightarrow$ Vector

\hspace*{10mm}\textcolor{red}{\textbf{Warning :} This method only works for two vectors with 3 components.}

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector&y&Vector $\overrightarrow{y}$ to use for the vector product operation.
\end{tcolorbox}

This method returns the vector product of two Vector defined by the following equation:
\begin{equation*}
\overrightarrow{w} = \overrightarrow{x}\land\overrightarrow{y},
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::ewInverse()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::ewInverse(~)}}\label{Vector::ewInverse()}\index[DL]{Vector!ewInverse(~)}\\
Element-wise inverse of a vector\\ \hspace*{10mm}$\hookrightarrow$ Vector

This method returns a vector containing the inverse of all elements of the vector.
\begin{equation*}
y_i = 1/x_i,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::ewExp()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::ewExp(~)}}\label{Vector::ewExp()}\index[DL]{Vector!ewExp(~)}\\
Element-wise exponential of a vector\\ \hspace*{10mm}$\hookrightarrow$ Vector

This method returns a vector containing the exponential of all elements of the vector.
\begin{equation*}
y_i = \exp(x_i),
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::ewProduct(Vector y)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::ewProduct(Vector y)}}\label{Vector::ewProduct(Vector y)}\index[DL]{Vector!ewProduct(Vector y)}\\
Element-wise product of two vectors.\\ \hspace*{10mm}$\hookrightarrow$ Vector

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
Vector&y&Vector $\overrightarrow{y}$ to use for the element-wise product operation.
\end{tcolorbox}

This method returns the vector product of two Vector defined by the following equation:
\begin{equation*}
w_i = x_i y_i,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::ewSquare()
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::ewSquare(~)}}\label{Vector::ewSquare()}\index[DL]{Vector!ewSquare(~)}\\
Element-wise square of a vector\\ \hspace*{10mm}$\hookrightarrow$ Vector

This method returns a vector containing the square of all elements of the vector.
\begin{equation*}
y_i = (x_i)^2,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END

%@DOC:Vector::ewSquare(double m)
%Warning :
%This area is an automatic documentation generated from the DynELA source code.
%Do not change anything in this latex file between this position and the @END keyword.
\textcolor{purple}{\textbf{Vector::ewSquare(double m)}}\label{Vector::ewSquare(double m)}\index[DL]{Vector!ewSquare(double m)}\\
Element-wise addition of a real to a vector\\ \hspace*{10mm}$\hookrightarrow$ Vector

\begin{tcolorbox}[width=\textwidth,myArgs,tabularx={ll|R}]
double&m&Value to add to all components of the vector
\end{tcolorbox}

This method returns a vector containing all elements of the given vector plus a quantity.
\begin{equation*}
y_i = x_i + m,
\end{equation*}
where the $\overrightarrow{x}$ is the object itself.
%@END


